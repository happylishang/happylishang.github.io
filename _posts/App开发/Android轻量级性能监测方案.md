
## 背景

关键性能指标是衡量APP质量必不可少的一环，目前严选线上性能指标值采集了Crash及网络，像帧率、APP启动、界面启动、内存、内存泄露等指标均缺乏，而且不同手机的表现相差也挺大，尤其对于Android，线上有几百种机型在跑，这部分指标的完善很重要。

其次，目前缺少一套基线，即：什么样的页面是符合性能要求，这个衡量的基本标准目前缺失，咨询了下云音乐，他们目前也没有线上性能监测能力，只是本地跑跑数据，目前业内给出的开源项目，大部分都是离线下本地数据采集，线上生产环境能直接跑的轻量级监测SDK还没有，所以这部分能力需要我们自己补全。


## 方案对比选择


   sdk名称      |  现状          | 能否直接线上用     |
--------------------|------------------|-----------------------|
腾讯matrix       | 太重，运行测试期间发现经常Crash不稳定      | 否   |
腾讯GT       | 3年没更新，适合线下跑跑  |否   |
网易Emmagee  | 3年多没更，基本废弃  |否        |
听云App    |  适合监测网络跟启动，场景受限  | 否   |
DoraemonKit哆啦A梦         | 功能强大，定位是本地看性能，需要剥离   | 否 |
360 ArgusAPM         |  没来及看     |  没来及看|
自研       |   保持轻量级，支持自定义，安全     |  是|


## 核心性能指标

* 网络状况（APM已经实现）
* 崩溃（Crash Firebase （Android端分析有点问题））
*  冷启动时间及各个页面启动时间
* 页面刷新帧率、卡顿（FPS、及瞬时帧率）
* 内存使用及内存泄露 
* 流量消耗（Flow）
*  电量
*  CPU使用率（CPU） ：还不知道有什么用

## 基线的制定（参考业界或者先线上跑跑）

### FPS基线(每秒传输帧数Frames Per Second）

从腾讯、百度各方的报告来看，用FPS来衡量是否卡顿并不科学，理想情况下FPS是60，在硬件没有特殊订制的情况，上限也是60，每16ms都能完成一帧的刷新，达到60肯定是不卡的，但是50的帧率卡顿吗？答案是不一定。平时看到的大部分电影或视频 FPS并不高，30FPS即可满足，一个稳定在 30FPS 的动画，并不卡顿，但如果FPS 很不稳定，却更容易感知到，这里有个词叫**稳定**，50的FPS如果是均分到各个节点，那么用户是感知不到掉帧的，但是，如果剩余的10帧是一次回执掉的，那用户的感知就很明显，也就是**瞬时帧率**的意义更大。

> 掉帧/跳帧/卡顿

理想帧率 60FPS 的情况下，每一帧 16.6667ms，如果一帧准备超出这个值，则认为发生掉帧，超出的时间越长，掉帧程度越严重。假设每帧准备时间约 32ms，每次只掉一帧，那么 1 秒内实际只刷新 30 帧，即平均帧率只有 30FPS，但这时往往不会觉得是卡顿。反而如果出现某次严重掉帧（>300ms），那么这一次的变化，通常很容易感知到。所以界面的掉帧程度，往往可以更直观的反映出卡顿。Matrix给的卡顿建议

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e52ff90fe76495fa656d02e96a123fc~tplv-k3u1fbpfcp-zoom-1.image)

相比单看平均帧率，掉帧程度的分布更能反应界面流畅程度。百度的流畅定义跟Martrix类似，区分了小卡顿与大卡顿，同样认为**瞬时大卡顿**是造成界面流畅度降低的核心原因。

结论：瞬时帧率能真实反应界面流畅度，一般瞬时帧率平局小于3的情况下，都可以认为界面流畅。



## FPS 


其实并非如此，举个例子，游戏玩家通常追求更流畅的游戏画面体验一般要达到 60FPS 以上，但我们平时看到的大部分电影或视频 FPS 其实不高，一般只有 25FPS ~ 30FPS，而实际上我们也没有觉得卡顿。 在人眼结构上看，当一组动作在 1 秒内有 12 次变化（即 12FPS），我们会认为这组动作是连贯的；而当大于 60FPS 时，人眼很难区分出来明显的变化，所以 60FPS 也一直作为业界衡量一个界面流畅程度的重要指标。一个稳定在 30FPS 的动画，我们不会认为是卡顿的，但一旦 FPS 很不稳定，人眼往往容易感知到。

FPS 低并不意味着卡顿发生，而卡顿发生 FPS 一定不高。 FPS 可以衡量一个界面的流程性，但往往不能很直观的衡量卡顿的发生，这里有另一个指标（掉帧程度）可以更直观地衡量卡顿。

什么是掉帧（跳帧）？ 按照理想帧率 60FPS 这个指标，计算出平均每一帧的准备时间有 1000ms/60 = 16.6667ms，如果一帧的准备时间超出这个值，则认为发生掉帧，超出的时间越长，掉帧程度越严重。假设每帧准备时间约 32ms，每次只掉一帧，那么 1 秒内实际只刷新 30 帧，即平均帧率只有 30FPS，但这时往往不会觉得是卡顿。反而如果出现某次严重掉帧（>300ms），那么这一次的变化，通常很容易感知到。所以界面的掉帧程度，往往可以更直观的反映出卡顿。

怎么衡量流程性
我们将掉帧数划分出几个区间进行定级，掉帧数小于 3 帧的情况属于最佳，依次类推，见下表：

Best	Normal	Middle	High	Frozen
[0:3)	[3:9)	[9:24)	[24:42)	[42:∞)


## 启动耗时

只需要以startActivity执行为起始点，以第一帧渲染为结束点，就能得出一个较为准确的耗时。

Launch耗时可以通过onCreate、onRestoreInstanceState、onStart、onResume四个函数的耗时相加得出。在这四个方法中，onCreate一般是最重的那个方法，因为很多变量的初始化都会放在这里进行。另外，onCreate方法中还有个耗时大户是LayoutInfalter.infalte方法，调用setContentView会执行到这个方法，对于一些复杂布局的第一次解析，会消耗大量时间。由于这四个方法是同步顺序执行的，单独把某些操作从onCreate移到onResume之类的并没有什么意义，Launch耗时只关心这几个方法的总耗时。
 
*  onWindowFocusChanged

 onWindowFocusChanged是测量第一次可见的时机 onresume跟onwindowforceChange一般不做耗时操作
 
、
 UI线程所有Msg执行都算掉帧 ，
 掉帧检测
 FPS计算逻辑：平均值意义不大，瞬时fps更有参考价值，或者说其稳定性，意义更大
 卡顿掉帧指标计算

掉帧/跳帧/抖动：帧率不稳
卡顿：卡在那不懂，也可以看做更严重的掉帧
