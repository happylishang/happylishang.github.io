---
layout: post
title: "一句代码创建全屏Dialog或者DialogFragment：带你从源码角度实现"
description: "Java"
category: android开发
 

---

默认情况下，实现的的Dialog都是wrap_content样式的，但是这种样式的对话框有很多限制，比如边距、宽度、高度不好控制等，但是如果我们能保证Dialog的跟布局同Activity一样，那样在布局的时候，可以完全按照常用的布局方式来处理。如何最简单的实现全屏Dialog呢，其实方法不一，这里挑个最简单的，然后说下原因。

# 实现方法

先看实现效果：![全屏Dialog](http://upload-images.jianshu.io/upload_images/1460468-81c39c48fa4e52e9.gif?imageMogr2/auto-orient/strip)

实现代码，第一步在style中定义全屏Dialog样式

    <style name="Dialog.FullScreen" parent="Theme.AppCompat.Dialog">
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowBackground">@color/transparent</item>
        <item name="android:windowIsFloating">false</item>
    </style>
    
第二步：设置样式，以DialogFragment为例，在onCreate中 setStyle(STYLE_NORMAL, R.style.Dialog_FullScreen)即可。（推荐使用DialogFragment，它复用了Fragment的声明周期，被杀死后，可以恢复重建）

	public class FragmentFullScreen extends DialogFragment {
	
	    @Nullable
	    @Override
	    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
	        return inflater.inflate(R.layout.fragment_full_screen, container,false);
	    }
	
	    @Override
	    public void onCreate(@Nullable Bundle savedInstanceState) {
	        super.onCreate(savedInstanceState);
	        setStyle(STYLE_NORMAL, R.style.Dialog_FullScreen);
	    }
	}

当然也可以采用其他手段，比如在onStart中设置强制全屏也能达到这样的效果，其实这里就引入一个问题，**为什么是在onStart函数中，onCreate中不行吗：确实不行，原因后面分析**

    @Override
    protected void onStart() {
        super.onStart();
        getWindow().setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT);
        getWindow().setBackgroundDrawable(new ColorDrawable(0x00000000));
    }

虽然上面的是针对DialogFragment，但是完全可以应用到Dialog中去，不在详述，下面分析一下原因。

# 实现原理

先分析一下Style样式的实现原理，为什么需要设置以下三个属性

        <item name="android:windowIsFloating">false</item>
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowBackground">@color/transparent</item>

首先看下第一个属性，android:windowIsFloating，这里可能是Activity默认样式同Dialog最大的区别之一，对比一下默认的Dialog主题与Activity主题,主题最终都是继承与Theme，在Theme中

> Theme

	 	<style name="Theme">
	 			...
	         <item name="windowIsFloating">false</item>
	    </style>
    
> Base.V7.Theme.AppCompat.Dialog

    <style name="Base.V7.Theme.AppCompat.Dialog" parent="Base.Theme.AppCompat">
        ...
        <item name="android:windowIsFloating">true</item>
        <item name="android:backgroundDimEnabled">true</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="android:windowAnimationStyle">@style/Animation.AppCompat.Dialog</item>
    </style>

Activity一般是没有覆盖windowIsFloating属性，也就是采用了默认的 <item name="windowIsFloating">false</item>，而Dialog的一般是True，这两者在创建Window的时候有什么区别呢？在PhoneWindow.java中，创建DecorView的时候是需要创建顶层布局参数的，Activity默认采用的是WindowManager的WindowManager.LayoutParams，Window默认实现的时候就是MATCH_PARENT：

    protected ViewGroup generateLayout(DecorView decor) {
        // Apply data from current theme.
        TypedArray a = getWindowStyle();
        mIsFloating = a.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating, false);
        int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR)
                & (~getForcedWindowFlags());
         <!--关键点1-->
        if (mIsFloating) {
            setLayout(WRAP_CONTENT, WRAP_CONTENT);
            setFlags(0, flagsToUpdate);
        } else {
            setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate);
        }
        ...       
    }

从关键点1可以看到，如果windowIsFloating被配置为true，就会通过setLayout(WRAP_CONTENT, WRAP_CONTENT)将Window的窗口属性设置为WRAP_CONTENT,而这个属性对于根布局参数的生成起着关键作用

    public void setLayout(int width, int height) {
        final WindowManager.LayoutParams attrs = getAttributes();
        attrs.width = width;
        attrs.height = height;
        if (mCallback != null) {
            mCallback.onWindowAttributesChanged(attrs);
        }
    }
这里是就直接改变WindowManager.LayoutParams 的值而回调会导致窗口重绘,对于Activity同样的原理，虽然在Window中 默认 WindowManager.LayoutParams mWindowAttributes = new WindowManager.LayoutParams();

之后在添加窗口的时候，resume的时候，让WMS添加View，其Window参数，就是上面的参数，

对于Activity而言，会导致参数发生变化，重回窗口

    public void onWindowAttributesChanged(WindowManager.LayoutParams params) {
        if (mParent == null) {
            View decor = mDecor;
            if (decor != null && decor.getParent() != null) {
                getWindowManager().updateViewLayout(decor, params);
            }
        }
    }

而最终会调用WindowManager的addView将View添加到WMS中


	final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) { 
	    
	    ActivityClientRecord r = performResumeActivity(token, clearHide); 
	
	    if (r != null) {
	        final Activity a = r.activity;
	
	        //...
	        if (r.window == null && !a.mFinished && willBeVisible) {
	            r.window = r.activity.getWindow(); 
	            View decor = r.window.getDecorView();
	            decor.setVisibility(View.INVISIBLE);
	            ViewManager wm = a.getWindowManager(); 
	            WindowManager.LayoutParams l = r.window.getAttributes();
	            a.mDecor = decor;
	            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
	            l.softInputMode |= forwardBit;
	            if (a.mVisibleFromClient) {
	                a.mWindowAdded = true;
	                wm.addView(decor, l);	            }
	            //...
	        }
	    }
	}

其实是调用WindowManagerGlobal的addView，这里有个很关键的参数params，其实传递过来的是WindowManager.LayoutParams l = r.window.getAttributes();如果是Dialog默认主题，该参数的宽高其实是WRAP_CONTENT

	public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        ...

        ViewRootImpl root;
        View panelParentView = null;
        synchronized (mLock) {
            ...
            root = new ViewRootImpl(view.getContext(), display); 
            <!--关键点1 -->
            view.setLayoutParams(wparams);
            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
        }
        try {
            root.setView(view, wparams, panelParentView); // 2
        } catch (RuntimeException e) {
            synchronized (mLock) {
                final int index = findViewLocked(view, false);
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
            }
            throw e;
        }
    }
	
    
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
    synchronized (this) {
	    ...
	    requestLayout();
	    ...
	    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
	                    getHostVisibility(), mDisplay.getDisplayId(),
	                    mAttachInfo.mContentInsets, mInputChannel);
      }
     
	     public void requestLayout() {
	    if (!mHandlingLayoutInLayoutRequest) {
	        checkThread();
	        mLayoutRequested = true;
	        scheduleTraversals();
	    }
	}

         void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            mTraversalBarrier = mHandler.getLooper().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            scheduleConsumeBatchedInput();
        }
    }
           
	           
	  private void performTraversals() {
	    final View host = mView; // 缓存为局部变量 host
	    ......
	   mIsInTraversal = true; // 表明现在正在performTraversals函数执行中
	    ......
	   if (mFirst) { // 如果是首次 requestLayout 则 mFullRedrawNeeded = mLayoutRequested = true，并执行 dispatchAttachedToWindow，此处是真正的 onAttachToWindow
	        mFullRedrawNeeded = true;
	        mLayoutRequested = true;
	        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL
	                || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) {
	            ......
	        } else {
	            DisplayMetrics packageMetrics =
	                mView.getContext().getResources().getDisplayMetrics();
	            desiredWindowWidth = packageMetrics.widthPixels;
	            desiredWindowHeight = packageMetrics.heightPixels;
	        }
	        ......
	        host.dispatchAttachedToWindow(attachInfo, 0);
	        ......
	    }
	    ......
	    boolean layoutRequested = mLayoutRequested && !mStopped;
	    if (layoutRequested) {
	        ......
	        // Ask host how big it wants to be
	       windowSizeMayChange |= measureHierarchy(host, lp, res,
	                desiredWindowWidth, desiredWindowHeight); // let's measure and onMeasure!
	    }
	
	    ......
	
	    if (layoutRequested) {
	       mLayoutRequested = false; // 重置为 false，表示本次requestLayout得到了处理
	    }
	
	    boolean windowShouldResize = layoutRequested && windowSizeMayChange
	        && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight())
	            || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &&
	                    frame.width() < desiredWindowWidth && frame.width() != mWidth)
	            || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &&
	                    frame.height() < desiredWindowHeight && frame.height() != mHeight)); // 窗体是否需要重新布局
	
	    ......
	
	    if (mFirst || windowShouldResize || insetsChanged ||
	            viewVisibilityChanged || params != null) {
	
	        ......
	
	        boolean hadSurface = mSurface.isValid();
	
	        try {
	            ......
	          relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); // 
	           
	            ......
	
	            if (!hadSurface) {
	                if (mSurface.isValid()) { // 如果本次是新建的 surface，则整个窗体需要重绘
	                   newSurface = true;
	                    mFullRedrawNeeded = true;
	                    ......
	                }
	            } else if (...) {
	                ......
	            } else if (...) {
	                ......
	            }
	        } catch (RemoteException e) {
	        }
	        ......
	    } else {
	        ......
	    }
	
	    final boolean didLayout = layoutRequested && !mStopped;
	    ......
	    if (didLayout) {
	      performLayout(lp, desiredWindowWidth, desiredWindowHeight); // 真正的 layout 和 onLayout
	        .......
	    }
	    ......
	    boolean cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() ||
	            viewVisibility != View.VISIBLE;
	
	    if (!cancelDraw && !newSurface) {
	        if (!skipDraw || mReportNextDraw) {
	            ......
	          performDraw(); // 真正的 draw 和 onDraw
	        }
	    } else {
	        if (viewVisibility == View.VISIBLE) {
	            // Try again
	            scheduleTraversals();
	        } else if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
	            for (int i = 0; i < mPendingTransitions.size(); ++i) {
	                mPendingTransitions.get(i).endChangingAnimations();
	            }
	            mPendingTransitions.clear();
	        }
	    }
	
	    mIsInTraversal = false;
		}
	
	
	measureHierarchy(host, lp, mView.getContext().getResources(),
	        desiredWindowWidth, desiredWindowHeight);
        

        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);
            

    private static int getRootMeasureSpec(int windowSize, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {

        case ViewGroup.LayoutParams.MATCH_PARENT:
            // Window can't resize. Force root view to be windowSize.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            // Window can resize. Set max size for root view.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            // Window wants to be an exact size. Force root view to be that size.
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
    }
    
                        
# 优点与缺点：消失的时机要自己定义，优点也恰恰是这一点，可以统一定义样式

 



### 参考文档

[Android 官方推荐 : DialogFragment 创建对话框](http://blog.csdn.net/lmj623565791/article/details/37815413)

[如何控制宽度](http://blog.csdn.net/zhyh1986/article/details/48655885)
[ Android Project Butter分析](http://blog.csdn.net/innost/article/details/8272867)