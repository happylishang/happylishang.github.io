---
layout: post
title: "一句代码创建全屏Dialog或者DialogFragment：带你从源码角度实现"
description: "Java"
category: android开发
image: http://upload-images.jianshu.io/upload_images/1460468-81c39c48fa4e52e9.gif?imageMogr2/auto-orient/strip
 

---

默认情况下，实现的的Dialog都是wrap_content样式的，但是这种样式的对话框有很多限制，比如边距、宽度、高度不好控制等，但是如果我们能保证Dialog的跟布局同Activity一样，那样在布局的时候，可以完全按照常用的布局方式来处理。如何最简单的实现全屏Dialog呢，其实方法不一，这里挑个最简单的，然后说下原因。Android的窗口管理以及View绘制是挺大的一块，很不好理解，这里从全屏Dialog的定制需求入手开个学习WMS的头。

# 全屏Dialog实现方法

先看实现效果：![全屏Dialog](http://upload-images.jianshu.io/upload_images/1460468-81c39c48fa4e52e9.gif?imageMogr2/auto-orient/strip)

实现代码，第一步在style中定义全屏Dialog样式

    <style name="Dialog.FullScreen" parent="Theme.AppCompat.Dialog">
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowBackground">@color/transparent</item>
        <item name="android:windowIsFloating">false</item>
    </style>
    
第二步：设置样式，以DialogFragment为例，在onCreate中 setStyle(STYLE_NORMAL, R.style.Dialog_FullScreen)即可。（推荐使用DialogFragment，它复用了Fragment的声明周期，被杀死后，可以恢复重建）

	public class FragmentFullScreen extends DialogFragment {
	
	    @Nullable
	    @Override
	    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
	        return inflater.inflate(R.layout.fragment_full_screen, container,false);
	    }
	
	    @Override
	    public void onCreate(@Nullable Bundle savedInstanceState) {
	        super.onCreate(savedInstanceState);
	        setStyle(STYLE_NORMAL, R.style.Dialog_FullScreen);
	    }
	}

当然也可以采用其他手段，比如在onStart中设置强制全屏也能达到这样的效果，其实这里就引入一个问题，**为什么是在onStart函数中，onCreate中不行吗：确实不行，原因后面分析**

    @Override
    protected void onStart() {
        super.onStart();
        getWindow().setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT);
        getWindow().setBackgroundDrawable(new ColorDrawable(0x00000000));
    }

虽然上面的是针对DialogFragment，但是完全可以应用到Dialog中去，不在详述，下面分析一下原因。

# 全屏Dialog实现原理

先分析一下Style样式的实现原理，为什么需要设置以下三个属性

        <item name="android:windowIsFloating">false</item>
        <item name="android:windowBackground">@color/transparent</item>
        <item name="android:windowNoTitle">true</item>

首先看下第一个属性，android:windowIsFloating，这里可能是Activity默认样式同Dialog最大的区别之一，对比一下默认的Dialog主题与Activity主题,主题最终都是继承与Theme，在Theme中

> Theme

	 	<style name="Theme">
	 			...
	         <item name="windowIsFloating">false</item>
	    </style>
    
> Base.V7.Theme.AppCompat.Dialog

    <style name="Base.V7.Theme.AppCompat.Dialog" parent="Base.Theme.AppCompat">
        ...
        <item name="android:windowIsFloating">true</item>
        <item name="android:backgroundDimEnabled">true</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="android:windowAnimationStyle">@style/Animation.AppCompat.Dialog</item>
    </style>

Activity一般是没有覆盖windowIsFloating属性，也就是采用了默认的 <item name="windowIsFloating">false</item>，而Dialog的一般是True，这两者在创建Window的时候有什么区别呢？在PhoneWindow.java中，创建DecorView的时候是需要创建顶层布局参数的，Activity默认采用的是WindowManager的WindowManager.LayoutParams，Window默认实现的时候就是MATCH_PARENT：

    protected ViewGroup generateLayout(DecorView decor) {
        // Apply data from current theme.
        TypedArray a = getWindowStyle();
        mIsFloating = a.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating, false);
        int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR)
                & (~getForcedWindowFlags());
         <!--关键点1-->
        if (mIsFloating) {
            setLayout(WRAP_CONTENT, WRAP_CONTENT);
            setFlags(0, flagsToUpdate);
        } else {
            setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate);
        }
        ...       
    }

从关键点1可以看到，如果windowIsFloating被配置为true，就会通过setLayout(WRAP_CONTENT, WRAP_CONTENT)将Window的窗口属性WindowManager.LayoutParams设置为WRAP_CONTENT,**这个属性对于根布局MeasureSpec参数的生成起着关键作用**

    public void setLayout(int width, int height) {
        final WindowManager.LayoutParams attrs = getAttributes();
        attrs.width = width;
        attrs.height = height;
        if (mCallback != null) {
            mCallback.onWindowAttributesChanged(attrs);
        }
    }
    
其实View真正显示的点是在Activity resume的时候，让WMS添加View，其Window参数，而最终会调用WindowManager的addView将View添加到WMS中，


	final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) { 
	    
	    ActivityClientRecord r = performResumeActivity(token, clearHide); 
	
	    if (r != null) {
	        final Activity a = r.activity;
	
	        //...
	        if (r.window == null && !a.mFinished && willBeVisible) {
	            r.window = r.activity.getWindow(); 
	            View decor = r.window.getDecorView();
	            decor.setVisibility(View.INVISIBLE);
	            ViewManager wm = a.getWindowManager(); 
	            WindowManager.LayoutParams l = r.window.getAttributes();
	            a.mDecor = decor;
	            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
	            l.softInputMode |= forwardBit;
	            if (a.mVisibleFromClient) {
	                a.mWindowAdded = true;
	                wm.addView(decor, l);	            }
	            //...
	        }
	    }
	}

其实是调用WindowManagerGlobal的addView，这里有个很关键的参数params，其实传递过来的是WindowManager.LayoutParams l = r.window.getAttributes();如果是Dialog默认主题，该参数的宽高其实是WRAP_CONTENT，这个参数是测量最初限定参数值的起点，也就是说，一个Window究竟多大，这个参数是有最终话语权的，不过具体的View绘制流程这不详述，只要记住Window的参数属性最终被传递到根DecorView中，进行measure，其实可以根据View performTraversals追踪到measureHierarchy，看一下里面是如何用Window布局参数的,这传递lp，其实就是window的参数，当然可能经过微调：

	measureHierarchy(final View host, final WindowManager.LayoutParams lp,
            final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) { 
				...
      	   childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
         childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);
       		... 
		 }  

    private static int getRootMeasureSpec(int windowSize, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {
        case ViewGroup.LayoutParams.MATCH_PARENT:
            // Window can't resize. Force root view to be windowSize.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            // Window can resize. Set max size for root view.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            // Window wants to be an exact size. Force root view to be that size.
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
    }
  
      private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure");
        try {
            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }
      
 最终会产生RootMeasureSpec，供DecorView使用，如果是Activity,这里其实就是传递屏幕MeasureSpec.EXACTLY+屏幕尺寸，如果是默认的Dialog，其实这里就是传递MeasureSpec.AT_MOST+屏幕尺寸，这里就是Dialog无法全屏的关键原因之一。 接着看第二属性 android:windowBackground，这个属性如果采用默认设置会有黑色边框：
 
         <item name="android:windowBackground">@color/transparent</item>
   
这里是因为默认采用了一些背景导致的InsetDrawable,设置了一些边距，导致上面的状态栏，底部的导航栏，左右边距

	<inset xmlns:android="http://schemas.android.com/apk/res/android"
	       android:insetLeft="16dp"
	       android:insetTop="16dp"
	       android:insetRight="16dp"
	       android:insetBottom="16dp">
	    <shape android:shape="rectangle">
	        <corners android:radius="2dp" />
	        <solid android:color="@color/background_floating_material_dark" />
	    </shape>
	</inset>

如上，DecorView在绘制的时候，会将这里的边距考虑进去，而且对于false的Dialog会将status及底部导航栏考虑进去。

# 怎么理解在onStart中设置才会有效

其实这里是个误解

    @Override
    protected void onStart() {
        super.onStart();
        View view = LayoutInflater.from(getContext()).inflate(R.layout.fragment_full_screen, null);
        setContentView(view, new ViewGroup.LayoutParams(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT));
        getWindow().setBackgroundDrawable(new ColorDrawable(0x00000000));
        getWindow().setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT);
    }

    @Override
    protected void onStart() {
        super.onStart();
        getWindow().setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT);
        View view = LayoutInflater.from(getContext()).inflate(R.layout.fragment_full_screen, null);
        setContentView(view, new ViewGroup.LayoutParams(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT));
        getWindow().setBackgroundDrawable(new ColorDrawable(0x00000000));

    }
    
上下两种的实现就会表现不一样，其实就是setContentView的调用顺序，setContentView会根据是够windowFloating定位Window的参数
                              
# 要自己处理状态栏，状态栏是一个独立的窗口

# 优点与缺点：消失的时机要自己定义，优点也恰恰是这一点，可以统一定义样式

### 参考文档

[Android 官方推荐 : DialogFragment 创建对话框](http://blog.csdn.net/lmj623565791/article/details/37815413)

[如何控制宽度](http://blog.csdn.net/zhyh1986/article/details/48655885)
[ Android Project Butter分析](http://blog.csdn.net/innost/article/details/8272867)
[浅析 android 应用界面的展现流程（四）创建绘制表面](http://3dobe.com/archives/120/)
[浅析Android的窗口](http://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=555)