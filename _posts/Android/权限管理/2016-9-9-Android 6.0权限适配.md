---
layout: post
title: "Android 6.0权限适配"
description: "Java"
category: android开发

---

# Android 6.0权限适配

* 为什么6.0权限需要适配
* 什么权限需要动态适配
* 怎样动态适配权限
* 怎么样实现第三方库简化代码及流程
* 几种实现的优缺点分析
* **targetSDKVersion从22换成23对用户影响**
* 国产ROM的权限管理
* 其他未分析的点
* 原理

# 为什么6.0需要权限适配


6.0之前Android的权限都是在安装的时候授予的，6.0之后，为了简化安装流程，并且方便用户控制权限，Android允许在运行的时候动态控制权限，对于开发而言就是将targetSdkVersion设置为23，当运行在Android 6.0 +的手机上时，就会调用6.0相关的API，达到动态控制权限的目的。

targetSdkVersion is the main way Android provides forward compatibility：targetSdkVersion 是 Android 系统提供前向兼容的主要手段。这是什么意思呢？随着 Android 系统的升级，某个系统的 API 或者模块的行为可能会发生改变，但是为了保证老 APK 的行为还是和以前兼容。只要 APK 的 targetSdkVersion 不变，即使这个 APK 安装在新 Android 系统上，其行为还是保持老的系统上的行为，这样就保证了系统对老应用的前向兼容，代码中可以通过Context getApplicationInfo().targetSdkVersion。 Android 系统升级，发生这种兼容行为的变化时，一般都会在原来的保存新旧两种逻辑，并通过 if-else 方法来判断执行哪种逻辑。在源码中有很多getApplicationInfo().targetSdkVersion < Buid.XXXX

* targetSDKVersion：标识App能够适配的系统版本，有些新的API是只有新的系统才有的
* compileSdkVersion：是你SDK的版本号，也就是你在编程时引用的android.jar的版本，一般都会和targetSDKVersion相等，或者比targetSDKVersion高，不能低，因为有些API与特性低版本没有。

# 什么权限需要动态适配

## 权限分类

并非所有的权限都需要动态申请，Android6.0将权限分为两种，普通权限跟敏感（危险）权限，普通权限是不需要动态申请的，但是敏感权限需要动态申请。

* 1、**普通权限**（Normal permissions）：不会泄露用户隐私，同时也不会导致手机安全问题。如网络请求权限、WIFI状态等，这类权限只需要在Manifest列出来，之后，系统会自动赋给APP权限：

	 * 	ACCESS_NETWORK_STATE    
	 * 	ACCESS_NOTIFICATION_POLICY      
	 * 	ACCESS_WIFI_STATE       
	 * 	BLUETOOTH			
	 * 	BLUETOOTH_ADMIN				

* 2、**敏感权限**（Dangerous permissions）：与普通权限对应，可能会影响用户的隐私，存储数据等，比如拍照、存储、通讯录、地理GPS等，这类权限需要在Manifest列出来，在需要的的时候，显示的请求用户准许。
 
	* 	CALENDAR	
	* 	CAMERA	
	* 	CONTACTS	
	* 	LOCATION	
	* 	PHONE	
	* 	SENSORS	
	* 	SMS	
	* 	STORAGE	
 
敏感权限的请求是按照分组进行提醒的，并非仅仅针对一条，比如通讯录的读取权限与写权限，只要一个权限获到，下次请求权限的时候会自动提供，当然也要请求。否则还是有问题。

* 3、**特殊权限**（Special Permissions） --未分析

  There are a couple of permissions that don't behave like normal and dangerous permissions. SYSTEM_ALERT_WINDOW and WRITE_SETTINGS 


# 怎样动态适配权限

## 原则：实时检查

权限随时可能被回收，比如用户可以在设置里面把权限给取消，但是APP并不一定知道，因此每次都需要检查，一旦没有，就需要请求，因此，如果可能，最好把权限的申请提前到onResume里面。

## 实现步骤

* 1、在Manifest中列出来

	无论普通权限还是敏感权限，都需要在Manifest中列出来，这其实是对6.0之前的版本的一种兼容。
	
		<manifest xmlns:android="http://schemas.android.com/apk/res/android"
	          package="com.snail.labaffinity">
	    <uses-permission android:name="android.permission.CAMERA"/>
	    <uses-permission android:name="android.permission.CALL_PHONE"/>
	    

* 2、需要时，显示的请求

	系统显示授权对话框，目前授权对话框不可定制，不过可以在申请之前添加一些解释，告诉用户为什么需要该权限，但是Google提醒，不要做过多的解释，可能会使用户感到厌烦。
	
	        ActivityCompat.requestPermissions(target.getActivity(), permissions, getNextRequestCode());
	        。。
		    public static void requestPermissions(final @NonNull Activity activity,
	            final @NonNull String[] permissions, final int requestCode) {

* 3、处理授权回调
	
	* 	需要兼容6.0之前的处理，只需要处理获得权限即可，因为，一旦安装，是没有版本取消权限的，但是国内ROM的可能需要特殊处理，
	* 	需要对6.0的授权成功、失败、永不询问做处理

		    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
		        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
		        if(this.mOnGrantedListener != null) {
		        <!--6.0之前-->
		            if(PermissionUtils.getTargetSdkVersion(this) < 23 && !PermissionUtils.hasSelfPermissions(this, permissions)) {
		                this.mOnGrantedListener.onGranted(this, permissions);
		                return;
		            }
		     <!--6.0之前-->
		            if(PermissionUtils.verifyPermissions(grantResults)) {
		                this.mOnGrantedListener.onGranted(this, permissions);
		            } else if(!PermissionUtils.shouldShowRequestPermissionRationale(this, permissions)) {
		                this.mOnGrantedListener.onNeverAsk(this, permissions);
		            } else {
		                this.mOnGrantedListener.onDenied(this, permissions);
		            }
		        }
		    }

# 具体APP中的做法：

* 1、简单的封装回调
* 2、使用第三方库简化代码及流程
* 3、基于APT，并自己封回调

## 采用最直接的回调

基类Activity设置最简单的回调监听：
 
	 public class BasePermissionCompatActivity extends AppCompatActivity {
	
	    private SparseArray<OnGrantedListener<BasePermissionCompatActivity>> mOnGrantedListeners = new SparseArray<>();
	
	    @Override
	    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
	        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
	        OnGrantedListener<BasePermissionCompatActivity> listener = mOnGrantedListeners.get(requestCode);
	        if (listener == null)
	            return;
	        if (PermissionUtils.verifyPermissions(grantResults)) {
	            listener.onGranted(this, permissions);
	        } else {
	            if (PermissionUtils.shouldShowRequestPermissionRationale(this, permissions)) {
	                listener.onDenied(this, permissions);
	            } else {
	                listener.onNeverAsk(this, permissions);
	            }
	        }
	    }
	    
	    @Override
	    protected void onDestroy() {
	        super.onDestroy();
	        mOnGrantedListeners.clear();
	        mOnGrantedListeners = null;
	    }
	
	    public void requestPermissions(final @NonNull String[] permissions, OnGrantedListener<BasePermissionCompatActivity> onGrantedListener) {
	        int requestCode = getNextRequestCode();
	        ActivityCompat.requestPermissions(this, permissions, requestCode);
	        mOnGrantedListeners.put(requestCode, onGrantedListener);
	    }
	
	    private static int sNextCode;
	
	    private static int getNextRequestCode() {
	        return sNextCode++;
	    }
	}
 
 在相应的Activity或者Fragment何时的地方请求接口即可，可以用到MVP开发中，放在persenter里面

        PermissionCompat.requestPermission(this, P_CAMERA, new OnGrantedListener() {

		    // 根据permissions自行处理，可合并，可分开
		    @Override
		    public void onGranted(SecondActivity target, String[] permissions,int requestCode) {
		        if (Arrays.equals(permissions, P_CALL)) {
		            LogUtils.v("P_CALL");
		        } else if (Arrays.equals(permissions, P_CAMERA)) {
		            LogUtils.v("P_CAMERA");
		        } else {
		            LogUtils.v("else");
		        }
		        ToastUtil.show(Arrays.toString(permissions) + " onGranted");
		    }
		
		    @Override
		    public void onDenied(SecondActivity target, String[] permissions,int requestCode) {
		        if (Arrays.equals(permissions, P_CALL)) {
		            LogUtils.v("P_CALL");
		        } else if (Arrays.equals(permissions, P_CAMERA)) {
		            LogUtils.v("P_CAMERA");
		        } else {
		            LogUtils.v("else");
		        }
		        ToastUtil.show(Arrays.toString(permissions) + " onDenied");
		    }
		
		    @Override
		    public void onNeverAsk(SecondActivity target, String[] permissions,int requestCode) {
		        if (Arrays.equals(permissions, P_CALL)) {
		            LogUtils.v("P_CALL");
		        } else if (Arrays.equals(permissions, P_CAMERA)) {
		            LogUtils.v("P_CAMERA");
		        } else {
		            LogUtils.v("else");
		        }
		        ToastUtil.show(Arrays.toString(permissions) + " onNeverAsk");
		    }
		
		    @Override
		    public void onShowRationale(SecondActivity target, String[] permissions,int requestCode) {
		        if (Arrays.equals(permissions, P_CALL)) {
		            LogUtils.v("P_CALL");
		        } else if (Arrays.equals(permissions, P_CAMERA)) {
		            LogUtils.v("P_CAMERA");
		        } else {
		            LogUtils.v("else");
		        }
		        ToastUtil.show(Arrays.toString(permissions) + " onShowRationale");
		    }
        });
        
 

# 使用PermissionDispatch库：注解+手动写回调（需要先build）

文档：[PermissionDispatcher](https://github.com/a1018875550/PermissionDispatcher)

依赖APT生成的代码，在Activity中手动添加代码，使用：

* 写注解，并build，生成Activity或者Fragment对象
* 基于生成的对象，在相应的位置手动添加请求代码
* 在相应的位置手动添加onRequestPermissionsResult代码

		public class   MainActivity extent AppcompatActivity{
			onResume{
				。。。。
			    MainActivityPermissionsDispatcher.showContactsWithCheck(this);
			}
			
		    @NeedsPermission(Manifest.permission.CAMERA)
		    void showCamera() {
		        // NOTE: Perform action that requires the permission. If this is run by PermissionsDispatcher, the permission will have been granted
		        getSupportFragmentManager().beginTransaction()
		                .replace(R.id.sample_content_fragment, CameraPreviewFragment.newInstance())
		                .addToBackStack("camera")
		                .commitAllowingStateLoss();
		    }
		    
		    @OnPermissionDenied(Manifest.permission.CAMERA)
		    void onCameraDenied() {
		        // NOTE: Deal with a denied permission, e.g. by showing specific UI
		        // or disabling certain functionality
		        Toast.makeText(this, R.string.permission_camera_denied, Toast.LENGTH_SHORT).show();
		    }
		
		    @OnNeverAskAgain(Manifest.permission.CAMERA)
		    void onCameraNeverAskAgain() {
		        Toast.makeText(this, R.string.permission_camera_never_askagain, Toast.LENGTH_SHORT).show();
		    }
		
		    @Override
		    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
		        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
		        // NOTE: delegate the permission handling to generated method
		        MainActivityPermissionsDispatcher.onRequestPermissionsResult(this, requestCode, grantResults);
		    }

 
# 自定义：基于APT与注解，实现编译过程中生成代码，并在调用时，自动添加回调

采用类似Butterknife做法：结合PermissionDispatch与回调的是现实方式，基于APT动态生成Listener，并且将onRequestPermissionsResult等一系列回调处理放在一个基类中，在请求权限时，通过反射找到相应的Listener，自动添加回调监听。

实现原理：

* 1、基于APT，定义一系列Annotation，并动态生成辅助Listener类
* 2、添加Android支持库，在基类统一处理回调，
* 3、添加工具类，连接绑定Listener与Activity（Fragment）

相应的实现分三个库：

* 注解库
* APT生成支持库
* Android支持库

## 注解库：

主要用来定义一些回调方法注解、及请求实体的类注解

	* ActivityPermission
	* FragmentPermission
	* OnDenied
	* OnGranted
	* OnGrantedListener
	* OnNeverAsk
	* OnShowRationale

## APT生成支持库

主要用来在编译阶段，动态生Listener类

	PermissionProcessor.java

部分参考代码：
	
	@AutoService(Processor.class)
	public class PermissionProcessor extends AbstractProcessor {
	
	    private Elements elementUtils;
	
	    private Set<Class<? extends Annotation>> getSupportedAnnotations() {
	        Set<Class<? extends Annotation>> annotations = new LinkedHashSet<>();
	        annotations.add(OnDenied.class);
	        annotations.add(OnGranted.class);
	        annotations.add(OnNeverAsk.class);
	        annotations.add(OnShowRationale.class);
	        return annotations;
	    }
	
	    @Override
	    public synchronized void init(ProcessingEnvironment env) {
	        super.init(env);
	        elementUtils = env.getElementUtils();
	    }
	
	    @Override
	    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
	        if (!checkIntegrity(roundEnv))
	            return false;
	        Set<? extends Element> elementActivities = roundEnv.getElementsAnnotatedWith(ActivityPermission.class);
	        Set<? extends Element> elementFragments = roundEnv.getElementsAnnotatedWith(FragmentPermission.class);
	        return makeListenerJavaFile(elementActivities) && makeListenerJavaFile(elementFragments);
	    }
       ...

##  Android支持库

主要会封装了一些工具类，基类以及对回调的处理

	* BasePermissionCompatActivity.java
	* BasePermissionCompatFragment.java
	* PermissionCompat.java
	* PermissionUtils.java

参考代码：
	
	public class PermissionCompat {
	
	    private static int sNextRequestCode;
	    static final Map<Class<?>, OnGrantedListener> BINDERS = new LinkedHashMap<>();
	
	    // 分批次请求权限
	    public static void requestPermission(BasePermissionCompatActivity target, String[] permissions) {
	
	        Class<?> targetClass = target.getClass();
	        try {
	           // 找到监听Listener类，并实例一个
	            OnGrantedListener<BasePermissionCompatActivity> listener = findOnGrantedListenerForClass(targetClass, permissions);
	            if (PermissionUtils.hasSelfPermissions(target, permissions)) {
	                listener.onGranted(target, permissions);
	            } else if (PermissionUtils.shouldShowRequestPermissionRationale(target, permissions)) {
	                // 拒绝过，再次请求的时候,这个函数是否有必要，不在询问后，返回false，第一次返回false，
	                //listener.onShowRationale(target, permissions);
	                startRequest(target, listener, permissions);
	            } else {
	                startRequest(target, listener, permissions);
	            }
	
	        } catch (Exception e) {
	            throw new RuntimeException("Unable to bind views for " + targetClass.getName(), e);
	        }
	    }
	
	    private static void startRequest(BasePermissionCompatActivity target, OnGrantedListener listener, final @NonNull String[] permissions) {
	        target.setOnGrantedListener(listener);
	        ActivityCompat.requestPermissions(target, permissions, getNextRequestCode());
	    }
    
## 使用

* 1、Activity继承BasePermissionCompatActivity
* 2、用注解写回调函数，支持权限分组，跟单独处理，但是每个分组都要写自己的回调函数（目前回调函数，不支持参数）
* 3、回调不需配套，也就是一个权限必须对应四个函数，否则编译不通过
* 4、请求的权限必须有回调函数，不然报运行时错误--崩溃
	
		@ActivityPermission
		public class PermssionActivity extends BasePermissionCompatActivity {
		
	     	。。。
	     
		    @OnGranted(value = {Manifest.permission.CAMERA})
		    void granted() {
		        LogUtils.v("granted");
		    }
		
		    @OnDenied(value = {Manifest.permission.CAMERA})
		    void onDenied() {
		        LogUtils.v("onDenied");
		    }
		
		    @OnNeverAsk(value = {Manifest.permission.CAMERA})
		    void OnNeverAsk() {
		        LogUtils.v("OnNeverAsk");
	 
		    }
		    @OnShowRationale(value = {Manifest.permission.CAMERA})
		    void OnShowRationale() {
		        LogUtils.v("OnShowRationale");
		    }    
			<!--何时的时机调用-->
			
		    @OnClick(R.id.get)
		    void get() {
		        PermissionCompat.requestPermission(this, new String[]{Manifest.permission.CAMERA});
		    }
		}

# 几种实现的优缺点分析

**无论哪种实现，都要参考交互，因为每种方案都或多或少有些限制**

## 直接写回调

* 	优点：代码逻辑简单，也可跟MVP结合：将回调监听放到P中
* 	缺点：需要开发者自己处理的相对多一些
	
## PermissionDispatch实现

* 	优点：基于注解，作者还写了个插件
* 	缺点：注解跟回调都要写代码，并且需要先build生成代码，才能使用相应ActivityXXX类，其次onRequestPermissionsResult需要手动处理
	
## 自定义库实现

* 	优点：基于注解，并封装回调，不用build，可直接写代码，另外回调封装在基类，不用自己写
* 	缺点：生成的回调监听是通过反射创建的，与ButterKnife类似。

# 对用户影响

* **高targetSDKVersion覆盖低版本，不存在问题**
* **低targetSDKVersion版本覆盖高版本，存在问题**

# 国产ROM兼容性

6.0之前权限管理即不是原生功能又没有制定相应标准，每个厂家的实现都是完全不同的，比如framework层这厂可能直接改framework源码来拦截请求，那厂的framework原封不动而仅仅靠ptrace实现。

### MIUI权限管理及问题6.0

* 没有再次询问的接口 都是按照neverask处理 修改了底层权限管理的库
* 拨打电话逻辑：直接拨打电话（每次都询问）

红米3 4.4.4 正常

### 360手机5.1 就算禁止了权限，还是没用，仍然可以打开

### 魅族手机menifest声明即可获取

5.1正常

### 华为手机，权限管理 

G7 5.1
获取是否获得权限的接口返回不准确，
国产ROM的权限管理更像系统的管理工具，或者说更像一个系统级的APP

## tips

## 拦截管理一般由两部分组成：

一个负责拦截的service和一个负责和用户交互并存储设置信息（允许，询问还是禁止）的app。这个app通常会实现一个provider来存储每个应用的设置信息，其实你的需求就是能读取这个provider。


# 其他未分析的点

* Defining and Enforcing Permissions
* Enforcing Permissions
* 一些坑 
 
# 参考文档

1、[Requesting Permissions at Run Time](https://developer.android.com/training/permissions/requesting.html)        
2、[PermissionDispatcher](https://github.com/a1018875550/PermissionDispatcher)       
3、[Android6.0权限适配之WRITE_EXTERNAL_STORAGE（SD卡写入）](http://unclechen.github.io/2016/03/06/Android6.0%E6%9D%83%E9%99%90%E9%80%82%E9%85%8D%E4%B9%8BSD%E5%8D%A1%E5%86%99%E5%85%A5/)