---
layout: post
title: "Android 6.0权限适配"
description: "Java"
category: android开发

---

* AppOpsManager 内部权限操作方式，是在是在Android 4.4版本支持的 (api 19)

checkOp()
http://www.cnblogs.com/0616--ataozhijia/p/5009718.html

		void setMode ( int code, int uid, String packageName, int mode)

这个是我们最需要的方法，改变app的权限设置，但偏偏被google隐藏了。
code代表具体的操作权限， mode代表要更改成的类型（允许 /禁止 / 提示）
正常情况下（如果OEM厂商没有做特殊处理），把AppOpsManager.java打包，引入jar包到工程内，是可以使用上述API接口的，

AppOpsService也会被注入到各个相关的系统服务中，进行权限操作的检验。

各个权限操作对应的系统服务（比如定位相关的Location Service，Audio相关的Audio Service等）中注入AppOpsService的判断。如果用户做了相应的设置，那么这些系统服务就要做出相应的处理。

（比如，LocationManagerSerivce的定位相关接口在实现时，会有判断调用该接口的app是否被用户设置成禁止该操作，如果有该设置，就不会继续进行定位。）


    public LocationManagerService(Context context) {
    
        super();
        mContext = context;
        mAppOps = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);
        
 
之前系统服务鉴别权限的入口在哪里？在每个服务的内部       

## 拦截代码

有了 noteOp() 函数，但是要完成权限的动态检查，还要在执行某项权限的时候执行 noteOp()。经过分析，大概有十多个服务被插入了权限检查函数。其中包括：ClipboardService, VibratorService, LocationManagerService, NotificationManagerService, GeofenceManager, GpsLocationProvider, IccSmsInterfaceManager, PhoneInterfaceManager, OutgoingCallBroadcaster, WifiService, ContentProvider, WindowManagerService 等等

## 定位服务

	  @Override
	    public void requestLocationUpdates(LocationRequest request, ILocationListener listener,
	            PendingIntent intent, String packageName) {
	        if (request == null) request = DEFAULT_LOCATION_REQUEST;
	        checkPackageName(packageName);
	        int allowedResolutionLevel = getCallerAllowedResolutionLevel();
	        checkResolutionLevelIsSufficientForProviderUse(allowedResolutionLevel,
	                request.getProvider());
	        WorkSource workSource = request.getWorkSource();
	        if (workSource != null && workSource.size() > 0) {
	            checkDeviceStatsAllowed();
	        }
	        boolean hideFromAppOps = request.getHideFromAppOps();
	        if (hideFromAppOps) {
	            checkUpdateAppOpsAllowed();
	        }
	        LocationRequest sanitizedRequest = createSanitizedRequest(request, allowedResolutionLevel);
	
	        final int pid = Binder.getCallingPid();
	        final int uid = Binder.getCallingUid();
	        // providers may use public location API's, need to clear identity
	        long identity = Binder.clearCallingIdentity();
	        try {
	            // We don't check for MODE_IGNORED here; we will do that when we go to deliver
	            // a location.
	            checkLocationAccess(pid, uid, packageName, allowedResolutionLevel);
	
	            synchronized (mLock) {
	                Receiver recevier = checkListenerOrIntentLocked(listener, intent, pid, uid,
	                        packageName, workSource, hideFromAppOps);
	                requestLocationUpdatesLocked(sanitizedRequest, recevier, pid, uid, packageName);
	            }
	        } finally {
	            Binder.restoreCallingIdentity(identity);
	        }
	    }
       
       boolean checkLocationAccess(int pid, int uid, String packageName, int allowedResolutionLevel) {
        int op = resolutionLevelToOp(allowedResolutionLevel);
        if (op >= 0) {
            if (mAppOps.checkOp(op, uid, packageName) != AppOpsManager.MODE_ALLOWED) {
                return false;
            }
        }

        if (getAllowedResolutionLevel(pid, uid) < allowedResolutionLevel) {
            return false;
        }

        return true;
    }
 
## SMS短消息服务

    @Override
    public void sendData(String callingPackage, String destAddr, String scAddr, int destPort,
            byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
        
        <!--检测是否Manifest文件是否有该权限-->
        mPhone.getContext().enforceCallingPermission(
                Manifest.permission.SEND_SMS,
                "Sending SMS message");
         <!--检测是否Manifest文件是否有该权限-->        
        if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(),
                callingPackage) != AppOpsManager.MODE_ALLOWED) {
            return;
        }
		<!--发消息-->
    }
    
    
如果没有权限会抛出SecurityException异常，外部没有捕获，一般来说就会崩溃，内部服务如何处理权限，如何区分时候有哪种权限 。
 
系统服务系统权限：
         
# Android 权限管理原理
	    
# Android 6.0动态获取权限流程分析

Android6.0权限获取流程

## 检查权限是否已经获取

PermissionChecker

    public static int checkPermission(@NonNull Context context, @NonNull String permission,
            int pid, int uid, String packageName) {
        if (context.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_DENIED) {
            return PERMISSION_DENIED;
        }

        String op = AppOpsManagerCompat.permissionToOp(permission);
        if (op == null) {
            return PERMISSION_GRANTED;
        }

        if (packageName == null) {
            String[] packageNames = context.getPackageManager().getPackagesForUid(uid);
            if (packageNames == null || packageNames.length <= 0) {
                return PERMISSION_DENIED;
            }
            packageName = packageNames[0];
        }

        if (AppOpsManagerCompat.noteProxyOp(context, op, packageName)
                != AppOpsManagerCompat.MODE_ALLOWED) {
            return PERMISSION_DENIED_APP_OP;
        }

        return PERMISSION_GRANTED;
    }
    
首先是

    @Override
    public int checkPermission(String permission, int pid, int uid) {
        if (permission == null) {
            throw new IllegalArgumentException("permission is null");
        }

        try {
            return ActivityManagerNative.getDefault().checkPermission(
                    permission, pid, uid);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }    


ContextImple.java

    /** @hide */
    @Override
    public int checkPermission(String permission, int pid, int uid, IBinder callerToken) {
        if (permission == null) {
            throw new IllegalArgumentException("permission is null");
        }

        try {
            return ActivityManagerNative.getDefault().checkPermissionWithToken(
                    permission, pid, uid, callerToken);
        } catch (RemoteException e) {
            return PackageManager.PERMISSION_DENIED;
        }
    }

ActivityManagerNative.java

    public int checkPermission(String permission, int pid, int uid)
            throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeString(permission);
        data.writeInt(pid);
        data.writeInt(uid);
        mRemote.transact(CHECK_PERMISSION_TRANSACTION, data, reply, 0);
        reply.readException();
        int res = reply.readInt();
        data.recycle();
        reply.recycle();
        return res;
    }
    

    public int checkPermission(String permission, int pid, int uid) {
        if (permission == null) {
            return PackageManager.PERMISSION_DENIED;
        }
        return checkComponentPermission(permission, pid, UserHandle.getAppId(uid), -1, true);
    }
    
调用ActivityManager.checkComponentPermission

    /**
     * This can be called with or without the global lock held.
     */
    int checkComponentPermission(String permission, int pid, int uid,
            int owningUid, boolean exported) {
        // We might be performing an operation on behalf of an indirect binder
        // invocation, e.g. via {@link #openContentUri}.  Check and adjust the
        // client identity accordingly before proceeding.
        Identity tlsIdentity = sCallerIdentity.get();
        if (tlsIdentity != null) {
            Slog.d(TAG, "checkComponentPermission() adjusting {pid,uid} to {"
                    + tlsIdentity.pid + "," + tlsIdentity.uid + "}");
            uid = tlsIdentity.uid;
            pid = tlsIdentity.pid;
        }

        if (pid == MY_PID) {
            return PackageManager.PERMISSION_GRANTED;
        }

        return ActivityManager.checkComponentPermission(permission, uid,
                owningUid, exported);
    }
    
ActivityManager.java调用AppGlobals.getPackageManager().checkUidPermission(permission, uid);

    /** @hide */
    public static int checkComponentPermission(String permission, int uid,
            int owningUid, boolean exported) {
        // Root, system server get to do everything.
        
        <!--root及System能获取所有权限-->
        if (uid == 0 || uid == Process.SYSTEM_UID) {
            return PackageManager.PERMISSION_GRANTED;
        }
        // Isolated processes don't get any permissions.
        if (UserHandle.isIsolated(uid)) {
            return PackageManager.PERMISSION_DENIED;
        }
        // If there is a uid that owns whatever is being accessed, it has
        // blanket access to it regardless of the permissions it requires.
        if (owningUid >= 0 && UserHandle.isSameApp(uid, owningUid)) {
            return PackageManager.PERMISSION_GRANTED;
        }
        // If the target is not exported, then nobody else can get to it.
        if (!exported) {
            Slog.w(TAG, "Permission denied: checkComponentPermission() owningUid=" + owningUid);
            return PackageManager.PERMISSION_DENIED;
        }
        if (permission == null) {
            return PackageManager.PERMISSION_GRANTED;
        }
        try {
            return AppGlobals.getPackageManager()
                    .checkUidPermission(permission, uid);
        } catch (RemoteException e) {
            // Should never happen, but if it does... deny!
            Slog.e(TAG, "PackageManager is dead?!?", e);
        }
        return PackageManager.PERMISSION_DENIED;
    }
    
最终调用PackageManagerService.java去查看是否有权限（这里正是国产ROM的无法无天的区域）
首先它通过调用getUserIdLP，去PackageManagerService.Setting.mUserIds数组中，根据uid查找uid（也就是package）的权限列表。一旦找到，就表示有相应的权限。
如果没有找到，那么再去PackageManagerService.mSystemPermissions中找。这些信息是启动时，从/system/etc/permissions/platform.xml中读取的。这里记录了一些系统级的应用的 uid 对应的 permission 。

## android6.0之前

	 public int checkUidPermission(String permName, int uid) {
	        final boolean enforcedDefault = isPermissionEnforcedDefault(permName);
	        synchronized (mPackages) {
	        <!--PackageManagerService.Setting.mUserIds数组中，根据uid查找uid（也就是package）的权限列表-->
	            Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));
	            if (obj != null) {
	                GrantedPermissions gp = (GrantedPermissions)obj;
	                if (gp.grantedPermissions.contains(permName)) {
	                    return PackageManager.PERMISSION_GRANTED;
	                }
	            } else {
	            <!--mSystemPermissions记录一些系统级的应用的 uid 对应的 permission->
	                HashSet<String> perms = mSystemPermissions.get(uid);
	                if (perms != null && perms.contains(permName)) {
	                    return PackageManager.PERMISSION_GRANTED;
	                }
	            }
	            if (!isPermissionEnforcedLocked(permName, enforcedDefault)) {
	                return PackageManager.PERMISSION_GRANTED;
	            }
	        }
	        return PackageManager.PERMISSION_DENIED;
	    }

## Android6.0+的checkUidPermission

	 @Override
	    public int checkUidPermission(String permName, int uid) {
	        final int userId = UserHandle.getUserId(uid);
	
	        if (!sUserManager.exists(userId)) {
	            return PackageManager.PERMISSION_DENIED;
	        }
	
	        synchronized (mPackages) {
	            Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));
	            if (obj != null) {
	                final SettingBase ps = (SettingBase) obj;
	                final PermissionsState permissionsState = ps.getPermissionsState();
	                if (permissionsState.hasPermission(permName, userId)) {
	                    return PackageManager.PERMISSION_GRANTED;
	                }
	                // Special case: ACCESS_FINE_LOCATION permission includes ACCESS_COARSE_LOCATION
	                if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) && permissionsState
	                        .hasPermission(Manifest.permission.ACCESS_FINE_LOCATION, userId)) {
	                    return PackageManager.PERMISSION_GRANTED;
	                }
	            } else {
	                ArraySet<String> perms = mSystemPermissions.get(uid);
	                if (perms != null) {
	                    if (perms.contains(permName)) {
	                        return PackageManager.PERMISSION_GRANTED;
	                    }
	                    if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) && perms
	                            .contains(Manifest.permission.ACCESS_FINE_LOCATION)) {
	                        return PackageManager.PERMISSION_GRANTED;
	                    }
	                }
	            }
	        }
	
	        return PackageManager.PERMISSION_DENIED;
	    }


PermissionsState.java (android-6.0\frameworks\base\services\core\java\com\android\server\pm)
	
    public boolean hasPermission(String name, int userId) {
        enforceValidUserId(userId);

        if (mPermissions == null) {
            return false;
        }

        PermissionData permissionData = mPermissions.get(name);
        return permissionData != null && permissionData.isGranted(userId);
    }


    
## 获取

ActivityCompat.java
	
	 public static void requestPermissions(final @NonNull Activity activity,
	            final @NonNull String[] permissions, final int requestCode) {
	        if (Build.VERSION.SDK_INT >= 23) {
	            ActivityCompatApi23.requestPermissions(activity, permissions, requestCode);
	        } else if (activity instanceof OnRequestPermissionsResultCallback) {
	        
	            Handler handler = new Handler(Looper.getMainLooper());
	            handler.post(new Runnable() {
	                @Override
	                public void run() {
	                    final int[] grantResults = new int[permissions.length];
	
	                    PackageManager packageManager = activity.getPackageManager();
	                    String packageName = activity.getPackageName();
	
	                    final int permissionCount = permissions.length;
	                    for (int i = 0; i < permissionCount; i++) {
	                        grantResults[i] = packageManager.checkPermission(
	                                permissions[i], packageName);
	                    }
	
	                    ((OnRequestPermissionsResultCallback) activity).onRequestPermissionsResult(
	                            requestCode, permissions, grantResults);
	                }
	            });
	        }
	    }

可以看到，如果是6.0以下，直接通过PackageManager直接查询是否在Mannfest里面申请了权限，并把查询结果通过onRequestPermissionsResult回调传给Activity或者Fragment。这里对于国产ROM而言，就可能是开发的一些棘手的地方，国产的权限管理有些厂商可能是直接修改framework源码来拦截请求，有些厂商保持framework不动，而仅仅靠ptrace实现。这就导致了对于权限判断其实是不准确的。在Android6.0+上，是通过ActivityCompatApi23来动态获取权限的。
	   
		class ActivityCompatApi23 {
	
	    public static void requestPermissions(Activity activity, String[] permissions,
	            int requestCode) {
	            ...
	        activity.requestPermissions(permissions, requestCode);  
	        
进而通过activity.requestPermissions去进一步执行

    public final void requestPermissions(@NonNull String[] permissions, int requestCode) {
        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
    }

Intent其实是通过PackageManager（ApplicationPackageManager实现类）获取的Intent
    
        public Intent buildRequestPermissionsIntent(@NonNull String[] permissions) {
        if (ArrayUtils.isEmpty(permissions)) {
           throw new NullPointerException("permission cannot be null or empty");
        }
        Intent intent = new Intent(ACTION_REQUEST_PERMISSIONS);
        intent.putExtra(EXTRA_REQUEST_PERMISSIONS_NAMES, permissions);
        intent.setPackage(getPermissionControllerPackageName());
        return intent;
    }
    
隐式的获取Activity组件相关信息，这里getPermissionControllerPackageName获取相应的包名，

ApplicationPackageManager.java (android-6.0\frameworks\base\core\java\android\app)

    @Override
    public String getPermissionControllerPackageName() {
        synchronized (mLock) {
            if (mPermissionsControllerPackageName == null) {
                try {
                    mPermissionsControllerPackageName = mPM.getPermissionControllerPackageName();
                } catch (RemoteException e) {
                    throw new RuntimeException("Package manager has died", e);
                }
            }
            return mPermissionsControllerPackageName;
        }
    }

最终通过PackageManagerService获取包名

PackageManagerService.java (android-6.0\frameworks\base\services\core\java\com\android\server\pm)

    @Override
    public String getPermissionControllerPackageName() {
        synchronized (mPackages) {
            return mRequiredInstallerPackage;
        }
    }

mRequiredInstallerPackage这个变量具体赋值是在PMS的构造器中：对于原生Android 6.0，权限管理的APP跟安装器是同一个

	mRequiredInstallerPackage = getRequiredInstallerLPr();

这里会得到PackageInstaller应用的相关信息，PackageInstaller负责应用的安装与卸载，里面还包含了对授权管理的一些逻辑。startActivityForResult启动的就是PackageInstaller中的GrantPermissionsActivity，该Activity主要负责权限的授予工作。

        <activity android:name=".permission.ui.GrantPermissionsActivity"
                android:configChanges="orientation|keyboardHidden|screenSize"
                android:excludeFromRecents="true"
                android:theme="@style/GrantPermissions">
            <intent-filter>
                <action android:name="android.content.pm.action.REQUEST_PERMISSIONS" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
	
这是一个类似于对话框的悬浮窗样式的Activity

    <style name="GrantPermissions" parent="Settings">
        <item name="android:windowIsFloating">true</item>
        <item name="android:windowElevation">@dimen/action_dialog_z</item>
        <item name="android:windowSwipeToDismiss">false</item>
    </style>
 
具体后续流程就通普通的startActivityForResult没太大区别，Activity的dispatchActivityResult已经对授权回调进行了封装。之后就是授权及更新设置逻辑（第二次检查就知道是否已经授权，如果授权就不应该再次请求）


## 如何更新RuntimePermission

利用GroupState更新

    private LinkedHashMap<String, GroupState> mRequestGrantPermissionGroups = new LinkedHashMap<>();


    @Override
    public void onPermissionGrantResult(String name, boolean granted, boolean doNotAskAgain) {
        GroupState groupState = mRequestGrantPermissionGroups.get(name);
        if (groupState.mGroup != null) {
            if (granted) {
                groupState.mGroup.grantRuntimePermissions(doNotAskAgain);
                groupState.mState = GroupState.STATE_ALLOWED;
            } else {
                groupState.mGroup.revokeRuntimePermissions(doNotAskAgain);
                groupState.mState = GroupState.STATE_DENIED;
            }
            updateGrantResults(groupState.mGroup);
        }
        if (!showNextPermissionGroupGrantRequest()) {
            setResultAndFinish();
        }
    }
    
    
    public boolean grantRuntimePermissions(boolean fixedByTheUser, String[] filterPermissions) {
        final int uid = mPackageInfo.applicationInfo.uid;

        // We toggle permissions only to apps that support runtime
        // permissions, otherwise we toggle the app op corresponding
        // to the permission if the permission is granted to the app.
        for (Permission permission : mPermissions.values()) {
            if (filterPermissions != null
                    && !ArrayUtils.contains(filterPermissions, permission.getName())) {
                continue;
            }

            if (mAppSupportsRuntimePermissions) {
                // Do not touch permissions fixed by the system.
                if (permission.isSystemFixed()) {
                    return false;
                }

                // Ensure the permission app op enabled before the permission grant.
                if (permission.hasAppOp() && !permission.isAppOpAllowed()) {
                    permission.setAppOpAllowed(true);
                    mAppOps.setUidMode(permission.getAppOp(), uid, AppOpsManager.MODE_ALLOWED);
                }

                // Grant the permission if needed.
                if (!permission.isGranted()) {
                    permission.setGranted(true);
                    mPackageManager.grantRuntimePermission(mPackageInfo.packageName,
                            permission.getName(), mUserHandle);
                }

                // Update the permission flags.
                if (!fixedByTheUser) {
                    // Now the apps can ask for the permission as the user
                    // no longer has it fixed in a denied state.
                    if (permission.isUserFixed() || permission.isUserSet()) {
                        permission.setUserFixed(false);
                        permission.setUserSet(true);
                        mPackageManager.updatePermissionFlags(permission.getName(),
                                mPackageInfo.packageName,
                                PackageManager.FLAG_PERMISSION_USER_FIXED
                                        | PackageManager.FLAG_PERMISSION_USER_SET,
                                0, mUserHandle);
                    }
                }
            } else {
                // Legacy apps cannot have a not granted permission but just in case.
                if (!permission.isGranted()) {
                    continue;
                }

                int killUid = -1;
                int mask = 0;

                // If the permissions has no corresponding app op, then it is a
                // third-party one and we do not offer toggling of such permissions.
                if (permission.hasAppOp()) {
                    if (!permission.isAppOpAllowed()) {
                        permission.setAppOpAllowed(true);
                        // Enable the app op.
                        mAppOps.setUidMode(permission.getAppOp(), uid, AppOpsManager.MODE_ALLOWED);

                        // Legacy apps do not know that they have to retry access to a
                        // resource due to changes in runtime permissions (app ops in this
                        // case). Therefore, we restart them on app op change, so they
                        // can pick up the change.
                        killUid = uid;
                    }

                    // Mark that the permission should not be be granted on upgrade
                    // when the app begins supporting runtime permissions.
                    if (permission.shouldRevokeOnUpgrade()) {
                        permission.setRevokeOnUpgrade(false);
                        mask |= PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE;
                    }
                }

                if (mask != 0) {
                    mPackageManager.updatePermissionFlags(permission.getName(),
                            mPackageInfo.packageName, mask, 0, mUserHandle);
                }

                if (killUid != -1) {
                    mActivityManager.killUid(uid, KILL_REASON_APP_OP_CHANGE);
                }
            }
        }

        return true;
    }

PackageManagerService
	
	 public PackageManagerService(Context context, Installer installer,
            boolean factoryTest, boolean onlyCore) {
            ...
            updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags);
   
    private void updatePermissionsLPw(String changingPkg,
            PackageParser.Package pkgInfo, String replaceVolumeUuid, int flags) {
            

        // IMPORTANT: There are two types of permissions: install and runtime.
        // Install time permissions are granted when the app is installed to
        // all device users and users added in the future. Runtime permissions
        // are granted at runtime explicitly to specific users. Normal and signature
        // protected permissions are install time permissions. Dangerous permissions
        // are install permissions if the app's target SDK is Lollipop MR1 or older,
        // otherwise they are runtime permissions. This function does not manage
        // runtime permissions except for the case an app targeting Lollipop MR1
        // being upgraded to target a newer SDK, in which case dangerous permissions
        // are transformed from install time to runtime ones.
          
      private void grantPermissionsLPw(PackageParser.Package pkg, boolean replace,
      String packageOfInterest) {
         ...
            String packageOfInterest) {         
                   case GRANT_INSTALL: {
                        // Revoke this as runtime permission to handle the case of
                        // a runtime permission being downgraded to an install one.
                        // Also in permission review mode we keep dangerous permissions
                        // for legacy apps
                        for (int userId : UserManagerService.getInstance().getUserIds()) {
                            if (origPermissions.getRuntimePermissionState(
                                    bp.name, userId) != null) {
                                // Revoke the runtime permission and clear the flags.
                                origPermissions.revokeRuntimePermission(bp, userId);
                                origPermissions.updatePermissionFlags(bp, userId,
                                      PackageManager.MASK_PERMISSION_FLAGS, 0);
                                // If we revoked a permission permission, we have to write.
                                changedRuntimePermissionUserIds = ArrayUtils.appendInt(
                                        changedRuntimePermissionUserIds, userId);
                            }
                        }
                        // Grant an install permission.
                        if (permissionsState.grantInstallPermission(bp) !=
                                PermissionsState.PERMISSION_OPERATION_FAILURE) {
                            changedInstallPermission = true;
                        }
                    } break;
                    
                 case GRANT_RUNTIME:
                    
            
	 @Override
	    public void grantRuntimePermission(String packageName, String name, final int userId) {
	        if (!sUserManager.exists(userId)) {
	            Log.e(TAG, "No such user:" + userId);
	            return;
	        }
	
	        mContext.enforceCallingOrSelfPermission(
	                android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS,
	                "grantRuntimePermission");
	
	        enforceCrossUserPermission(Binder.getCallingUid(), userId,
	                true /* requireFullPermission */, true /* checkShell */,
	                "grantRuntimePermission");
	
	        final int uid;
	        final SettingBase sb;
	
	        synchronized (mPackages) {
	            final PackageParser.Package pkg = mPackages.get(packageName);
	            if (pkg == null) {
	                throw new IllegalArgumentException("Unknown package: " + packageName);
	            }
	
	            final BasePermission bp = mSettings.mPermissions.get(name);
	            if (bp == null) {
	                throw new IllegalArgumentException("Unknown permission: " + name);
	            }
	
	            enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp);
	
	            // If a permission review is required for legacy apps we represent
	            // their permissions as always granted runtime ones since we need
	            // to keep the review required permission flag per user while an
	            // install permission's state is shared across all users.
	            if ((mPermissionReviewRequired || Build.PERMISSIONS_REVIEW_REQUIRED)
	                    && pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M
	                    && bp.isRuntime()) {
	                return;
	            }
	
	            uid = UserHandle.getUid(userId, pkg.applicationInfo.uid);
	            sb = (SettingBase) pkg.mExtras;
	            if (sb == null) {
	                throw new IllegalArgumentException("Unknown package: " + packageName);
	            }
	
	            final PermissionsState permissionsState = sb.getPermissionsState();
	
	            final int flags = permissionsState.getPermissionFlags(name, userId);
	            if ((flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) {
	                throw new SecurityException("Cannot grant system fixed permission "
	                        + name + " for package " + packageName);
	            }
	
	            if (bp.isDevelopment()) {
	                // Development permissions must be handled specially, since they are not
	                // normal runtime permissions.  For now they apply to all users.
	                if (permissionsState.grantInstallPermission(bp) !=
	                        PermissionsState.PERMISSION_OPERATION_FAILURE) {
	                    scheduleWriteSettingsLocked();
	                }
	                return;
	            }
	
	            if (pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M) {
	                Slog.w(TAG, "Cannot grant runtime permission to a legacy app");
	                return;
	            }
	
	            final int result = permissionsState.grantRuntimePermission(bp, userId);
	            switch (result) {
	                case PermissionsState.PERMISSION_OPERATION_FAILURE: {
	                    return;
	                }
	
	                case PermissionsState.PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED: {
	                    final int appId = UserHandle.getAppId(pkg.applicationInfo.uid);
	                    mHandler.post(new Runnable() {
	                        @Override
	                        public void run() {
	                            killUid(appId, userId, KILL_APP_REASON_GIDS_CHANGED);
	                        }
	                    });
	                }
	                break;
	            }
	
	            mOnPermissionChangeListeners.onPermissionsChanged(uid);
				<!--持久化-->	
	            // Not critical if that is lost - app has to request again.
	            mSettings.writeRuntimePermissionsForUserLPr(userId, false);
	        }
	        
 <!--查询是否在Manifest声明过权限-->
 
     private static void enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(PackageParser.Package pkg,
            BasePermission bp) {
        int index = pkg.requestedPermissions.indexOf(bp.name);
        if (index == -1) {
            throw new SecurityException("Package " + pkg.packageName
                    + " has not requested permission " + bp.name);
        }
        if (!bp.isRuntime() && !bp.isDevelopment()) {
            throw new SecurityException("Permission " + bp.name
                    + " is not a changeable permission type");
        }
    }
 
 PermissionsState.java
 
     private int grantPermission(BasePermission permission, int userId) {
        if (hasPermission(permission.name, userId)) {
            return PERMISSION_OPERATION_FAILURE;
        }

        final boolean hasGids = !ArrayUtils.isEmpty(permission.computeGids(userId));
        final int[] oldGids = hasGids ? computeGids(userId) : NO_GIDS;

        PermissionData permissionData = ensurePermissionData(permission);

        if (!permissionData.grant(userId)) {
            return PERMISSION_OPERATION_FAILURE;
        }

        if (hasGids) {
            final int[] newGids = computeGids(userId);
            if (oldGids.length != newGids.length) {
                return PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED;
            }
        }

        return PERMISSION_OPERATION_SUCCESS;
    }
       
 <!--动态添加更新内存Permison  -->
    
        private PermissionData ensurePermissionData(BasePermission permission) {
        if (mPermissions == null) {
            mPermissions = new ArrayMap<>();
        }
        PermissionData permissionData = mPermissions.get(permission.name);
        if (permissionData == null) {
            permissionData = new PermissionData(permission);
            mPermissions.put(permission.name, permissionData);
        }
        return permissionData;
    }
    
## 权限状态持久化存在哪里
 
 Settings.java
 
     public void writeRuntimePermissionsForUserLPr(int userId, boolean sync) {
        if (sync) {
            mRuntimePermissionsPersistence.writePermissionsForUserSyncLPr(userId);
        } else {
            mRuntimePermissionsPersistence.writePermissionsForUserAsyncLPr(userId);
        }
    }
    
Settings.getPackageLPw这个方法，这是在安装应用扫描的时候scanPackageDirtyLI方法调用的，里面可以看到Settings类中的mUserIds、mPackages里面存的value还有PackageManagerService中的mPackages.pkg. mExtras都是同一个玩意奏是个PackageSetting。其实上面说的检查权限的流程是本来就有的，差异，差异，差异仅在于可以动态修改：也就是修改PermissionState的mGranted值。

  
      private File getUserRuntimePermissionsFile(int userId) {
        // TODO: Implement a cleaner solution when adding tests.
        // This instead of Environment.getUserSystemDirectory(userId) to support testing.
        File userDir = new File(new File(mSystemDir, "users"), Integer.toString(userId));
        return new File(userDir, RUNTIME_PERMISSIONS_FILE_NAME);
    }
      
在目录data/system/0/runtime-permissions.xml存放需要运行时申请的权限，Android6.0以上才有

	  <pkg name="com.snail.labaffinity">
	    <item name="android.permission.CALL_PHONE" granted="true" flags="0" />
	    <item name="android.permission.CAMERA" granted="false" flags="1" />
	  </pkg>

这些持久化的数据会在手机启动的时候由PMS读取

    public PackageManagerService(Context context, Installer installer,
            boolean factoryTest, boolean onlyCore) {
        ....
        mSettings = new Settings(mPackages);
        ....
        mFirstBoot = !mSettings.readLPw(sUserManager.getUsers(false));

    Settings(File dataDir, Object lock) {

        mRuntimePermissionsPersistence = new RuntimePermissionPersistence(mLock);

	<!--加载package信息-->

根据SettingsFile或者BackupSettingsFile读取相应的设置信息 生成PackageSetting对象，里面有权限列表字段protected final PermissionsState mPermissionsState;，之后再运行中，动态权限的操作都是针对这个对象

    boolean readLPw(@NonNull List<UserInfo> users) {
        FileInputStream str = null;
        if (mBackupSettingsFilename.exists()) {
            try {
                str = new FileInputStream(mBackupSettingsFilename);
                mReadMessages.append("Reading from backup settings file\n");
         ...
            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
                    && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
            
                String tagName = parser.getName();
                if (tagName.equals("package")) {
                
           !--读取package信息，包括install权限信息（对于Android6.0package.xml）-->
        
        readPackageLPw(parser); 
 			...
 			
          <!--读取runtime权限信息-->
          
        for (UserInfo user : users) {
            mRuntimePermissionsPersistence.readStateForUserSyncLPr(user.id);
        }
    }
    
    
    private void readPackageLPw(XmlPullParser parser) throws XmlPullParserException, IOException {
        String name = null;
         ...
        (tagName.equals(TAG_PERMISSIONS)) {
                readInstallPermissionsLPr(parser,
                            packageSetting.getPermissionsState());
                                    
之后就可以checkpermission了

	   @Override
	    public int checkUidPermission(String permName, int uid) {
	        final int userId = UserHandle.getUserId(uid);
	
	        if (!sUserManager.exists(userId)) {
	            return PackageManager.PERMISSION_DENIED;
	        }
	
	        synchronized (mPackages) {
	            Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));
	            if (obj != null) {
	                final SettingBase ps = (SettingBase) obj;
	                final PermissionsState permissionsState = ps.getPermissionsState();
	                if (permissionsState.hasPermission(permName, userId)) {
	                    return PackageManager.PERMISSION_GRANTED;
	                }
  


# Android6.0之前，原生ROM并不支持动态管理权限，国产ROM各有各的做法

只能动态检查权限（第三方ROM除外）

原来的权限存放位置在哪？不会都从Android Manifest清单去读取，只会在启动时读取一次。Android6.0之前会吧所有的权限都放置在data/system/packages.xml文件中。Android6.0之后，分为运行时权限跟普通权限，普通权限还是放在data/system/packages.xml中，运行时权限防止在data/system/users/0/runtime-permissions.xml文件中。根据运行时是否动态申请去更新权限。


    
# Android6.0申请普通权限会怎么样 

Android6.0里，普通权限仍然按照运行时权限的模型，只是granted="true"，就是永远是取得授权的。

    <perms>
        <item name="android.permission.INTERNET" granted="true" flags="0" />
        <item name="android.permission.ACCESS_WIFI_STATE" granted="true" flags="0" />
    </perms>


    private void readPackageLPw(XmlPullParser parser) throws XmlPullParserException, IOException {
        String name = null;
        ...
		if (tagName.equals("perms")) {
		                    readGrantedPermissionsLPw(parser, packageSetting.grantedPermissions);
		                    packageSetting.permissionsFixed = true;
		                } 
                

	 private void readGrantedPermissionsLPw(XmlPullParser parser, HashSet<String> outPerms)
	            throws IOException, XmlPullParserException {
	        int outerDepth = parser.getDepth();
	        int type;
	        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
	                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
	            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
	                continue;
	            }
	
	            String tagName = parser.getName();
	            if (tagName.equals(TAG_ITEM)) {
	                String name = parser.getAttributeValue(null, ATTR_NAME);
	                if (name != null) {
	                    outPerms.add(name.intern());
	                } else {
	                    PackageManagerService.reportSettingsProblem(Log.WARN,
	                            "Error in package manager settings: <perms> has" + " no name at "
	                                    + parser.getPositionDescription());
	                }
	            } else {
	                PackageManagerService.reportSettingsProblem(Log.WARN,
	                        "Unknown element under <perms>: " + parser.getName());
	            }
	            XmlUtils.skipCurrentTag(parser);
	        }
	    }
	

    <package name="com.android.providers.telephony"

    packageSetting = addPackageLPw(name.intern(), realName, new File(codePathStr),
            new File(resourcePathStr), legacyNativeLibraryPathStr, primaryCpuAbiString,
            secondaryCpuAbiString, cpuAbiOverrideString, userId, versionCode, pkgFlags,
            pkgPrivateFlags, parentPackageName, null);
                        
        PackageSetting addPackageLPw(String name, String realName, File codePath, File resourcePath,
            String legacyNativeLibraryPathString, String primaryCpuAbiString,
            String secondaryCpuAbiString, String cpuAbiOverrideString, int uid, int vc, int
            pkgFlags, int pkgPrivateFlags, String parentPackageName,
            List<String> childPackageNames) {
        PackageSetting p = mPackages.get(name);
        if (p != null) {
            if (p.appId == uid) {
                return p;
            }
            PackageManagerService.reportSettingsProblem(Log.ERROR,
                    "Adding duplicate package, keeping first: " + name);
            return null;
        }
        p = new PackageSetting(name, realName, codePath, resourcePath,
                legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString,
                cpuAbiOverrideString, vc, pkgFlags, pkgPrivateFlags, parentPackageName,
                childPackageNames);
        p.appId = uid;
        if (addUserIdLPw(uid, p, name)) {
            mPackages.put(name, p);
            return p;
        }
        return null;
    }
    
    
    
    private boolean addUserIdLPw(int uid, Object obj, Object name) {
        if (uid > Process.LAST_APPLICATION_UID) {
            return false;
        }

        if (uid >= Process.FIRST_APPLICATION_UID) {
            int N = mUserIds.size();
            final int index = uid - Process.FIRST_APPLICATION_UID;
            while (index >= N) {
                mUserIds.add(null);
                N++;
            }
            if (mUserIds.get(index) != null) {
                PackageManagerService.reportSettingsProblem(Log.ERROR,
                        "Adding duplicate user id: " + uid
                        + " name=" + name);
                return false;
            }
            mUserIds.set(index, obj);
        } else {
            if (mOtherUserIds.get(uid) != null) {
                PackageManagerService.reportSettingsProblem(Log.ERROR,
                        "Adding duplicate shared id: " + uid
                                + " name=" + name);
                return false;
            }
            mOtherUserIds.put(uid, obj);
        }
        return true;
    }

    public Object getUserIdLPr(int uid) {
        if (uid >= Process.FIRST_APPLICATION_UID) {
            final int N = mUserIds.size();
            final int index = uid - Process.FIRST_APPLICATION_UID;
            return index < N ? mUserIds.get(index) : null;
        } else {
            return mOtherUserIds.get(uid);
        }
    }                    	

	class GrantedPermissions {
    int pkgFlags;


    HashSet<String> grantedPermissions = new HashSet<String>();

	PackageSettingBase   
	
	PackageSetting
	
	 
# 没有权限，又没有请求，会怎么表现

前提：menifest里面一定要先注册

* Android6.0会直接崩溃
* Android6.0以下表现不一，一般对于其他Service的请求会返回null

# 参考文档

1、[Android 安全機制概述 Permission](http://fanli7.net/a/JAVAbiancheng/ANT/20121203/265086.html)       
2、[android permission权限与安全机制解析](http://www.mobile-open.com/2015/89851.html)      
3、[android6.0权限管理原理](http://m.blog.csdn.net/article/details?id=52187392)