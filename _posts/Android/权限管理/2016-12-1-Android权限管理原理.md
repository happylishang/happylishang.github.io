---
layout: post
title: "Android 6.0权限适配"
description: "Java"
category: android开发

---

# Android 权限管理原理


 
# 6.0之前

只能动态检查权限（第三方ROM除外）

ContextImple.java

    /** @hide */
    @Override
    public int checkPermission(String permission, int pid, int uid, IBinder callerToken) {
        if (permission == null) {
            throw new IllegalArgumentException("permission is null");
        }

        try {
            return ActivityManagerNative.getDefault().checkPermissionWithToken(
                    permission, pid, uid, callerToken);
        } catch (RemoteException e) {
            return PackageManager.PERMISSION_DENIED;
        }
    }

ActivityManagerNative.java

    public int checkPermission(String permission, int pid, int uid)
            throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeString(permission);
        data.writeInt(pid);
        data.writeInt(uid);
        mRemote.transact(CHECK_PERMISSION_TRANSACTION, data, reply, 0);
        reply.readException();
        int res = reply.readInt();
        data.recycle();
        reply.recycle();
        return res;
    }
    

    public int checkPermission(String permission, int pid, int uid) {
        if (permission == null) {
            return PackageManager.PERMISSION_DENIED;
        }
        return checkComponentPermission(permission, pid, UserHandle.getAppId(uid), -1, true);
    }
    
调用ActivityManager.checkComponentPermission

    /**
     * This can be called with or without the global lock held.
     */
    int checkComponentPermission(String permission, int pid, int uid,
            int owningUid, boolean exported) {
        // We might be performing an operation on behalf of an indirect binder
        // invocation, e.g. via {@link #openContentUri}.  Check and adjust the
        // client identity accordingly before proceeding.
        Identity tlsIdentity = sCallerIdentity.get();
        if (tlsIdentity != null) {
            Slog.d(TAG, "checkComponentPermission() adjusting {pid,uid} to {"
                    + tlsIdentity.pid + "," + tlsIdentity.uid + "}");
            uid = tlsIdentity.uid;
            pid = tlsIdentity.pid;
        }

        if (pid == MY_PID) {
            return PackageManager.PERMISSION_GRANTED;
        }

        return ActivityManager.checkComponentPermission(permission, uid,
                owningUid, exported);
    }
    
ActivityManager.java调用AppGlobals.getPackageManager().checkUidPermission(permission, uid);

    /** @hide */
    public static int checkComponentPermission(String permission, int uid,
            int owningUid, boolean exported) {
        // Root, system server get to do everything.
        
        <!--root及System能获取所有权限-->
        if (uid == 0 || uid == Process.SYSTEM_UID) {
            return PackageManager.PERMISSION_GRANTED;
        }
        // Isolated processes don't get any permissions.
        if (UserHandle.isIsolated(uid)) {
            return PackageManager.PERMISSION_DENIED;
        }
        // If there is a uid that owns whatever is being accessed, it has
        // blanket access to it regardless of the permissions it requires.
        if (owningUid >= 0 && UserHandle.isSameApp(uid, owningUid)) {
            return PackageManager.PERMISSION_GRANTED;
        }
        // If the target is not exported, then nobody else can get to it.
        if (!exported) {
            Slog.w(TAG, "Permission denied: checkComponentPermission() owningUid=" + owningUid);
            return PackageManager.PERMISSION_DENIED;
        }
        if (permission == null) {
            return PackageManager.PERMISSION_GRANTED;
        }
        try {
            return AppGlobals.getPackageManager()
                    .checkUidPermission(permission, uid);
        } catch (RemoteException e) {
            // Should never happen, but if it does... deny!
            Slog.e(TAG, "PackageManager is dead?!?", e);
        }
        return PackageManager.PERMISSION_DENIED;
    }
    
最终调用PackageManagerService.java去查看是否有权限（这里正是国产ROM的无法无天的区域）
首先它通过调用getUserIdLP，去PackageManagerService.Setting.mUserIds数组中，根据uid查找uid（也就是package）的权限列表。一旦找到，就表示有相应的权限。
如果没有找到，那么再去PackageManagerService.mSystemPermissions中找。这些信息是启动时，从/system/etc/permissions/platform.xml中读取的。这里记录了一些系统级的应用的 uid 对应的 permission 。

	 public int checkUidPermission(String permName, int uid) {
	        final boolean enforcedDefault = isPermissionEnforcedDefault(permName);
	        synchronized (mPackages) {
	        <!--PackageManagerService.Setting.mUserIds数组中，根据uid查找uid（也就是package）的权限列表-->
	            Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));
	            if (obj != null) {
	                GrantedPermissions gp = (GrantedPermissions)obj;
	                if (gp.grantedPermissions.contains(permName)) {
	                    return PackageManager.PERMISSION_GRANTED;
	                }
	            } else {
	            <!--mSystemPermissions记录一些系统级的应用的 uid 对应的 permission->
	                HashSet<String> perms = mSystemPermissions.get(uid);
	                if (perms != null && perms.contains(permName)) {
	                    return PackageManager.PERMISSION_GRANTED;
	                }
	            }
	            if (!isPermissionEnforcedLocked(permName, enforcedDefault)) {
	                return PackageManager.PERMISSION_GRANTED;
	            }
	        }
	        return PackageManager.PERMISSION_DENIED;
	    }


PermissionsState.java (android-6.0\frameworks\base\services\core\java\com\android\server\pm)
	
	public boolean hasPermission(String name, int userId) {
	enforceValidUserId(userId);
	
	if (mPermissions == null) {
	return false;
	}

	PermissionData permissionData = mPermissions.get(name);
	return permissionData != null && permissionData.isGranted(userId);
	}
	    
# 6.0开始--底层支持动态权限

请求源码

ActivityCompat.java
	
	 public static void requestPermissions(final @NonNull Activity activity,
	            final @NonNull String[] permissions, final int requestCode) {
	        if (Build.VERSION.SDK_INT >= 23) {
	            ActivityCompatApi23.requestPermissions(activity, permissions, requestCode);
	        } else if (activity instanceof OnRequestPermissionsResultCallback) {
	        
	       <!--可以看到，如果是6.0一下，就直接通过PMS来判定-->
	            Handler handler = new Handler(Looper.getMainLooper());
	            handler.post(new Runnable() {
	                @Override
	                public void run() {
	                    final int[] grantResults = new int[permissions.length];
	
	                    PackageManager packageManager = activity.getPackageManager();
	                    String packageName = activity.getPackageName();
	
	                    final int permissionCount = permissions.length;
	                    for (int i = 0; i < permissionCount; i++) {
	                        grantResults[i] = packageManager.checkPermission(
	                                permissions[i], packageName);
	                    }
	
	                    ((OnRequestPermissionsResultCallback) activity).onRequestPermissionsResult(
	                            requestCode, permissions, grantResults);
	                }
	            });
	        }
	    }
	   
		class ActivityCompatApi23 {
	    public interface RequestPermissionsRequestCodeValidator {
	        public void validateRequestPermissionsRequestCode(int requestCode);
	    }
	
	    public static void requestPermissions(Activity activity, String[] permissions,
	            int requestCode) {
	        if (activity instanceof RequestPermissionsRequestCodeValidator) {
	            ((RequestPermissionsRequestCodeValidator) activity)
	                    .validateRequestPermissionsRequestCode(requestCode);
	        }
	        activity.requestPermissions(permissions, requestCode);
	    }
	
	    public static boolean shouldShowRequestPermissionRationale(Activity activity,
	            String permission) {
	        return activity.shouldShowRequestPermissionRationale(permission);
	    }
	}
   
	    public final void requestPermissions(@NonNull String[] permissions, int requestCode) {
        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
    }      
 
ApplicationPackageManager.java (android-6.0\frameworks\base\core\java\android\app)

	public String getPermissionControllerPackageName() {
	synchronized (mLock) {
	if (mPermissionsControllerPackageName == null) {
	try {
	mPermissionsControllerPackageName = mPM.getPermissionControllerPackageName();
	} catch (RemoteException e) {
	throw new RuntimeException("Package manager has died", e);
	}
	}
	return mPermissionsControllerPackageName;
	}
	}

mPM：IPackageManager，PackageManagerService实现了这个接口，所以这里往下执行到了PMS。


PackageManagerService.java (android-6.0\frameworks\base\services\core\java\com\android\server\pm)

	@Override
	public String getPermissionControllerPackageName() {
	synchronized (mPackages) {
	return mRequiredInstallerPackage;
	}
	}

mRequiredInstallerPackage这个变量具体赋值是在PMS的构造器中：

	mRequiredInstallerPackage = getRequiredInstallerLPr();

实际上这里得到的是PackageInstaller这个应用的相关信息。PackageInstaller主要负责应用的安装与卸载。
综上所述，startActivityForResult启动的是PackageInstaller应用中的一个Activity，该Activity主要负责权限的授予工作。中间如何启动Activity的过程，这里不再作任何描述。这个Activity的配置信息如下：

	<activity android:name=".permission.ui.GrantPermissionsActivity"
	android:configChanges="orientation|keyboardHidden|screenSize"
	android:excludeFromRecents="true"
	android:theme="@style/GrantPermissions">
	<intent-filter>
	<action android:name="android.content.pm.action.REQUEST_PERMISSIONS" />
	<category android:name="android.intent.category.DEFAULT" />
	</intent-filter>
	</activity>

# 没有权限，表现如何，直接使用会崩溃吗？

# 参考文档

1、[Android 安全機制概述 Permission](http://fanli7.net/a/JAVAbiancheng/ANT/20121203/265086.html)       
2、[android permission权限与安全机制解析](http://www.mobile-open.com/2015/89851.html)      
3、[android6.0权限管理原理](http://m.blog.csdn.net/article/details?id=52187392)