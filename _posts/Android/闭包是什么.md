#### 闭包就是：函数可以捕获并使用定义时的作用域中的变量。

	
	fun makeCounter(): () -> Int {
	    var count = 0
	    return {
	        count++ // ← 这个 lambda 是闭包，它“记住”了 count
	    }
	}
	
	val counter = makeCounter()
	println(counter()) // 0
	println(counter()) // 1


很多高阶函数的 lambda 是闭包	

* 高阶函数就像：你请朋友来你家做菜（你给他一个“函数”）
* 闭包就像：这个朋友来你家，居然还用上了你冰箱里的调料（访问了外部变量）

		@Composable
		fun ActionButton(text: String, onClick: () -> Unit) {
		    Button(onClick = onClick) {
		        Text(text)
		    }
		}
		
		 @Composable
		fun CounterScreen() {
		    var count by remember { mutableStateOf(0) }
		    Column {
		        Text("Count: $count")
		        // 下面的 lambda 是闭包，捕获了 count 变量
		        ActionButton("加一") {
		            count++  // ✅ 闭包：lambda 中访问了外部 count 变量  
		        }
		    }
		}


### 到底是 “lambda 是闭包”？还是 “函数是闭包”？两者一样吗？

> 闭包（Closure）是一个行为特征，不是语法形式。
 
*  ✅ Lambda 是闭包（如果它捕获了外部变量）
 
* ✅ 函数也可以是闭包（如果它捕获了外部变量）
 
* ❗️不是所有 lambda 或函数都是闭包，只有捕获了外部变量的函数或 lambda 才是闭包



### “lambda 表达式” 是写法（语法），“lambda 函数” 是运行时的对象（函数值）。


	val x = { a: Int -> a + 1 }


* { a: Int -> a + 1 } → 是 lambda 表达式（语法形式）
* x 是一个 lambda 函数，类型是 (Int) -> Int，是一个值，可以调用：x(2) → 3

		{ x -> x + 1 }       ← 这是 lambda 表达式（语法）
		      ↓ 赋值或传参后
		val f = { x -> x + 1 } ← 变量 f 是 lambda 函数（值）
		      ↓ 调用
		f(3) → 4
