很多文章将Binder框架定义了四个角色：Server，Client，ServiceManager、以及Binder驱动，但这容易将人引导到歧途：好像所有的Binder服务都需要去ServiceManager去注册才能使用，其实不是这样。例如，平时APP开发通过bindService启动的服务，以及有些自己定义的AIDL远程调用，都不一定都ServiceManager注册这条路，**个人理解：ServiceManager主要功能是：管理系统服务，比如AMS、WMS、PKMS服务等**，而APP通过的bindService启动的Binder服务其实是由SystemServer的ActivityManagerService负责管理。这篇主要关注Android APP Java层Binder通信一些奇葩点：

*  ServiceManager addService的限制（并非服务都能使用ServiceManager的addService）
*  bindService启动Service与Binder服务实体的流程 
*  Java层Binder实体与与BinderProxy是如何实例化及使用的，与Native层的关系是怎样的
*  Parcel readStrongBinder与writeStrongBinder的原理（首先两端知晓）
*  数据传递参数AIDL单向与双向（inout）
     
# ServiceManager addService的限制--并非服务都能通过addService添加到ServiceManager

ServiceManager其实主要的面向对象是系统服务，大部分系统服务都是由SystemServer进程总添加到ServiceManager中去的，在通过ServiceManager添加服务的时候，是有些权限校验的，源码如下：

	int svc_can_register(unsigned uid, uint16_t *name)
	 {
	    unsigned n;
	    // 谁有权限add_service 0进程，或者 AID_SYSTEM进程
	    if ((uid == 0) || (uid == AID_SYSTEM))
	        return 1;
		 for (n = 0; n < sizeof(allowed) / sizeof(allowed[0]); n++)
	        if ((uid == allowed[n].uid) && str16eq(name, allowed[n].name))
	            return 1;
	    return 0;
	}
可以看到 (uid == 0) 或者 (uid == AID_SYSTEM)的进程都是可以添加服务的，uid=0，代表root用户，而uid=AID_SYSTEM，代表系统用户	。或者是一些特殊的配置进程。SystemServer进程在被Zygote创建的时候，就被分配了UID 是AID_SYSTEM（1000），

    private static boolean startSystemServer()
            throws MethodAndArgsCaller, RuntimeException {
        /* Hardcoded command line to start the system server */
        String args[] = {
            "--setuid=1000",
            "--setgid=1000",
            "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,3001,3002,3003,3006,3007",
            "--capabilities=130104352,130104352",
            "--runtime-init",
            "--nice-name=system_server",
            "com.android.server.SystemServer",
        };

Android每个APP的UID，都是不同的，用了Linux的UID那一套，但是没完全沿用，这里不探讨，**总之，普通的进程是没有权限注册到ServiceManager中的，那么APP平时通过bindService启动的服务怎么注册于查询的呢？接管这个任务的就是SystemServer的ActivityManagerService**。

## bindService启动Service与Binder服务实体的流程 （ActivityManagerService） 

bindService比startService多了一套Binder通信，其余的流程基本相同，而startService的流程，同startActivity差不多，四大组件的启动流程这里不做分析点，主要看bindService中C/S通信的建立流程，在这个流程里面，APP与服务端互为C/S的特性更明显，

* 1、Activity调用bindService函数通知ActivityManagerService，要启动Service这个服务
* 2、ActivityManagerService创建Servicerecord，并且ApplicationThreadProxy回调，在MainActivity所在的进程内部把Service启动起来，并且调用它的onCreate函数； 
* 3、ActivityManagerService把Service启动起来后，继续调用onBind函数，让Service返回一个Binder对象给它，以便AMS传递给Activity
* 4、ActivityManagerService把从Service处得到这个Binder对象传给Activity，即把这个Binder对象作为参数传递给Activity内部定义的ServiceConnection对象的onServiceConnected函数；这里是通过IserviceConnection binder实现。
* 5、Activity内部定义的ServiceConnection对象的onServiceConnected函数在得到这个Binder对象后，就通过它的getService成同函数获得CounterService接口，封装跟拆解       
* 6、Java层的mRemote本身都是BinderProxy


