*  基于AIDL的bindservice的流程 
*  Java层BinderProxy的实例化（通过Parcel的read）
*  Parcel readStrongBinder与writeStrongBinder的原理（首先两端知晓）
*  Java层Binder实体与Binder引用是如何实例化及使用的，与Native层的关系是怎样的
*  binder_thread中的 struct binder_transaction *transaction_stack有什么用 ？
*  数据传递参数AIDL 单向与双向 （inout）

这篇主要分析Android Java层对于Binder通信的支持，			
很多分析文章将Binder框架定义了四个角色：Server，Client，ServiceManager、以及Binder驱动，但这容易将人引导到歧途：好像所有的Binder服务都需要去ServiceManager去注册才能使用，其实不是这样。例如，平时APP开发通过bindService启动的服务，以及有些自己定义的AIDL远程调用，都不一定都ServiceManager注册这条路，**个人理解：ServiceManager主要功能是：管理系统服务，比如AMS、WMS、PKMS服务等**。而APP开发使用的bindService启动的服务基本是由SystemServer的ActivityManagerService负责管理。
 
     
Binder的transaction有3种类型：

call: 发起进程的线程不一定是在Binder线程， 接收者只指向进程，并不确定会有哪个线程来处理，所以不指定线程；
reply: 发起者一定是binder线程，并且接收者线程便是上次call时的发起线程(该线程不一定是binder线程，可以是任意线程)。
async: 与call类型差不多，唯一不同的是async是oneway方式不需要回复，发起进程的线程不一定是在Binder线程， 接收者只指向进程，并不确定会有哪个线程来处理，所以不指定线程。

 

Binder客户端或者服务端向Binder Driver发送的命令都是以BC_开头,例如本文的BC_TRANSACTION和BC_REPLY, 所有Binder Driver向Binder客户端或者服务端发送的命令则都是以BR_开头, 例如本文中的BR_TRANSACTION和BR_REPLY.
只有当BC_TRANSACTION或者BC_REPLY时, 才调用binder_transaction()来处理事务. 并且都会回应调用者一个BINDER_WORK_TRANSACTION_COMPLETE事务, 经过binder_thread_read()会转变成BR_TRANSACTION_COMPLETE.
startService过程便是一个非oneway的过程, 那么oneway的通信过程如下所述.

## oneway

当收到BR_TRANSACTION_COMPLETE则程序返回,有人可能觉得好奇,为何oneway怎么还要等待回应消息? 我举个例子,你就明白了.

你(app进程)要给远方的家人(system_server进程)邮寄一封信(transaction), 你需要通过邮寄员(Binder Driver)来完成.整个过程如下:

你把信交给邮寄员(BC_TRANSACTION);
邮寄员收到信后, 填一张单子给你作为一份回执(BR_TRANSACTION_COMPLETE). 这样你才放心知道邮递员已确定接收信, 否则就这样走了,信到底有没有交到邮递员手里都不知道,这样的通信实在太让人不省心, 长时间收不到远方家人的回信, 无法得知是在路的中途信件丢失呢,还是压根就没有交到邮递员的手里. 所以说oneway也得知道信是投递状态是否成功.
邮递员利用交通工具(Binder Driver),将信交给了你的家人(BR_TRANSACTION);
当你收到回执(BR_TRANSACTION_COMPLETE)时心里也不期待家人回信, 那么这便是一次oneway的通信过程.

如果你希望家人回信, 那便是非oneway的过程,在上述步骤2后并不是直接返回,而是继续等待着收到家人的回信, 经历前3个步骤之后继续执行:

家人收到信后, 立马写了个回信交给邮递员BC_REPLY;
同样,邮递员要写一个回执(BR_TRANSACTION_COMPLETE)给你家人;
邮递员再次利用交通工具(Binder Driver), 将回信成功交到你的手上(BR_REPLY)
这便是一次完成的非oneway通信过程.

oneway与非oneway: 都是需要等待Binder Driver的回应消息BR_TRANSACTION_COMPLETE. 主要区别在于oneway的通信收到BR_TRANSACTION_COMPLETE则返回,而不会再等待BR_REPLY消息的到来. 另外，oneway的binder IPC则接收端无法获取对方的pid.


  
[参考文档 http://gityuan.com/2016/09/04/binder-start-service/](http://gityuan.com/2016/09/04/binder-start-service/)

# 并非所有的进程 都能add_Service

 判断进程的uid是否有资格注册名称为name的服务
 
	int svc_can_register(unsigned uid, uint16_t *name)
	{
	    unsigned n;
	    
	    // 谁有权限add_service 0进程，或者 AID_SYSTEM进程
	    if ((uid == 0) || (uid == AID_SYSTEM))
	        return 1;
	
	    for (n = 0; n < sizeof(allowed) / sizeof(allowed[0]); n++)
	        if ((uid == allowed[n].uid) && str16eq(name, allowed[n].name))
	            return 1;
	
	    return 0;
	}
	

*  判断uid是否有资格注册名称为name的服务
*  如果用户是root用户或system用户，不用判断直接可以注册
*  所以，如果Server进程权限不够root和system，那么请记住要在allowed中添加相应的项。
	
	
		static struct {
		    unsigned uid;
		    const char *name;
		} allowed[] = {
		    { AID_MEDIA, "media.audio_flinger" },
		    { AID_MEDIA, "media.log" },
		    { AID_MEDIA, "media.player" },
		    { AID_MEDIA, "media.camera" },
		    { AID_MEDIA, "media.audio_policy" },
		    { AID_DRM,   "drm.drmManager" },
		    { AID_NFC,   "nfc" },
		    { AID_BLUETOOTH, "bluetooth" },
		    { AID_RADIO, "radio.phone" },
		    { AID_RADIO, "radio.sms" },
		    { AID_RADIO, "radio.phonesubinfo" },
		    { AID_RADIO, "radio.simphonebook" },
		/* TODO: remove after phone services are updated: */
		    { AID_RADIO, "phone" },
		    { AID_RADIO, "sip" },
		    { AID_RADIO, "isms" },
		    { AID_RADIO, "iphonesubinfo" },
		    { AID_RADIO, "simphonebook" },
		    { AID_MEDIA, "common_time.clock" },
		    { AID_MEDIA, "common_time.config" },
		    { AID_KEYSTORE, "android.security.keystore" },
		};
 


#  linux中的用户（UID）、组（GID）、进程（PID)

UserID 不同于UID，uid在安装以及系统启动的时候，就已经确定了

在 Linux 中，一个用户 UID 标示一个给定用户。Linux系统中的用户(UID)分为3类，即普通用户、根用户、系统用户。

      普通用户是指所有使用Linux系统的真实用户，这类用户可以使用用户名及密码登录系统。Linux有着极为详细的权限设置，所以一般来说普通用户只能在其家目录、系统临时目录或其他经过授权的目录中操作，以及操作属于该用户的文件。通常普通用户的UID大于500，因为在添加普通用户时，系统默认用户ID从500开始编号。
      根用户也就是root用户，它的ID是0，也被称为超级用户，root账户拥有对系统的完全控制权：可以修改、删除任何文件，运行任何命令。所以root用户也是系统里面最具危险性的用户，root用户甚至可以在系统正常运行时删除所有文件系统，造成无法挽回的灾难。所以一般情况下，使用root用户登录系统时需要十分小心。
      系统用户是指系统运行时必须有的用户，但并不是指真实的使用者。比如在RedHat或CentOS下运行网站服务时，需要使用系统用户apache来运行httpd进程，而运行MySQL数据库服务时，需要使用系统用户mysql来运行mysqld进程。在RedHat或CentOS下，系统用户的ID范围是1~499。下面给出的示例显示的是目前系统运行的进程，第一列是运行该进程的用户。

       组(GID)又是什么呢？事实上，在Linux下每个用户都至少属于一个组。举个例子：每个学生在学校使用学号来作为标识，而每个学生又都属于某一个班级，这里的学号就相当于UID，而班级就相当于GID。当然了，每个学生可能还会同时参加一些兴趣班，而每个兴趣班也是不同的组。也就是说，每个学生至少属于一个组，也可以同时属于多个组。在Linux下也是一样的道理


