---
layout: default
title: "Binder再剖析"
categories: [Android]

---


# Binder传输数据的大小限制

# Binder的同步跟异步

# Binder的执行线程与注册线程 

# Binder的查询

# Binder服务线程LOOP原理

# Binder驱动中的四棵树

红黑树节点的产生过程

另一个要考虑的东西就是binder_proc里的那4棵树啦。前文在阐述binder_get_thread()时，已经看到过向threads树中添加节点的动作。那么其他3棵树的节点该如何添加呢？其实，秘密都在传输动作中。要知道，binder驱动在传输数据的时候，可不是仅仅简单地递送数据噢，它会分析被传输的数据，找出其中记录的binder对象，并生成相应的树节点。如果传输的是个binder实体对象，它不仅会在发起端对应的nodes树中添加一个binder_node节点，还会在目标端对应的refs_by_desc树、refs_by_node树中添加一个binder_ref节点，而且让binder_ref节点的node域指向binder_node节点

[](http://static.oschina.net/uploads/img/201308/15213415_Dm2n.png)
![](http://static.oschina.net/uploads/img/201308/15213415_Dm2n.png)

使用及添加时机不同，refs_by_desc主要是用在客户端使用的时候，refs_by_node主要是在getService添加的时候

很多分析将Binder框架定义了四个角色：Server，Client，ServiceManager（以后简称SMgr）以及Binder驱动，其实这是容易将人引导到歧途，比如我们平时使用AIDL定义服务，并通信的时候，也许你觉得是注册到ServiceManager，其实不是，用户的Service是ActivityManagerService负责的。

其中Server，Client，SMgr运行于用户空间，驱动运行于内核空间。这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，SMgr是域名服务器（DNS），驱动是路由器。


Bp flags = 0 单向

  BpBinder.h
      virtual status_t    transact(   uint32_t code,
                                    const Parcel& data,
                                    Parcel* reply,
                                    uint32_t flags = 0);
                                    
                                    
     // TF_ONE_WAY == 1 
    // 并非单向，阻塞请求
    if ((flags & TF_ONE_WAY) == 0) {
        #if 0
        if (code == 4) { // relayout
            ALOGI(">>>>>> CALLING transaction 4");
        } else {
            ALOGI(">>>>>> CALLING transaction %d", code);
        }
        #endif
        if (reply) {
            err = waitForResponse(reply);
        } else {
            Parcel fakeReply;
            err = waitForResponse(&fakeReply);
        }
        #if 0
        if (code == 4) { // relayout
            ALOGI("<<<<<< RETURNING transaction 4");
        } else {
            ALOGI("<<<<<< RETURNING transaction %d", code);
        }
        #endif
        
        IF_LOG_TRANSACTIONS() {
            TextOutput::Bundle _b(alog);
            alog << "BR_REPLY thr " << (void*)pthread_self() << " / hand "
                << handle << ": ";
            if (reply) alog << indent << *reply << dedent << endl;
            else alog << "(none requested)" << endl;
        }
    } else {
        err = waitForResponse(NULL, NULL);
    }
    
    return err;
    
    
    
    
    
        // Is the read buffer empty?
    const bool needRead = mIn.dataPosition() >= mIn.dataSize();
    
    // We don't want to write anything if we are still reading
    // from data left in the input buffer and the caller
    // has requested to read the next data.

 

    // 如果正在读取数据，就不要再写请求，因为可能同时返回多个返回，一次性处理多个，先通知发完了，并且没有返回，

    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;
    
    bwr.write_size = outAvail;
    bwr.write_buffer = (long unsigned int)mOut.data();

    // This is what we'll read.
    if (doReceive && needRead) {
        // 在这里把接受数据的size跟大小获取到，注意一次获取的大小，传递的大小，其实不用传递mIn，mOut，传递数据大小及地址就行
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (long unsigned int)mIn.data();
    } else {
        bwr.read_size = 0;
        bwr.read_buffer = 0;
    }
    
    

(08) 在跳出while循环之后，会更新consumed的值。即，更新bwr.read_consumed的值。此时，由于写入了BR_NOOP和BR_TRANSACTION_COMPLETE两个指令，bwr.read_consumed=8。
    
说明： (01) 此时，因为在waitForResponse()中已经通过mIn.readInt32()读取了4个字节，因此mIn.dataPosition()=4，而mIn.dataSize()=8；因此，needRead=false。
(02) needRead=false，而doReceive=true；因此，outAvail=0。
最终，由于 bwr.write_size和bwr.read_size都为0，因此直接返回NO_ERROR。
再次回到waitForResponse()中，此时读出的cmd为BR_TRANSACTION_COMPLETE。此时，由于reply不为NULL，因此再次重新执行while循环，调用talkWithDriver()。
(01) 此时，已经读取了mIn中的全部数据，因此mIn.dataPosition()=8，而mIn.dataSize()=8；因此，needRead=true。
(02) outAvail=mOut.dataSize()，前面已经将mOut清空，因此outAvail=0。bwr初始化完毕之后，各个成员的值如下：


[参考文档](http://wangkuiwu.github.io/2014/09/05/BinderCommunication-AddService01/)
    
# Binder传输数据的大小限制


	#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2)) 
	
看ProcessState.cpp中对于内存的定义是不超过1M ,


从内容可以看出这个异常与Binder有关，产生这个异常的原因是由于系统对使用Binder交换数据的buffer大小进行了限制，大小为1M。 

看内核中，的讲述时不超过SZ_4M

  static int binder_mmap(struct file *filp, struct vm_area_struct *vma)
{
	int ret;
	struct vm_struct *area;
	struct binder_proc *proc = filp->private_data;
	const char *failure_string;
	struct binder_buffer *buffer;

	if ((vma->vm_end - vma->vm_start) > SZ_4M)
		vma->vm_end = vma->vm_start + SZ_4M;
		
		
    
    
#  参考文档

[Android Binder 分析——通信模型](http://light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B/)            
