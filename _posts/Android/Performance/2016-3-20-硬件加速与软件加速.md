---
layout: default
title: 硬件加速与软件加速
category: Java

---

#### Unsupported Drawing Operations

When hardware accelerated, the 2D rendering pipeline supports the most commonly used Canvas drawing operations as well as many less-used operations. All of the drawing operations that are used to render applications that ship with Android, default widgets and layouts, and common advanced visual effects such as reflections and tiled textures are supported.

The following table describes the support level of various operations across API levels:

	First supported API level
	
	Canvas
	
	drawBitmapMesh() (colors array)	18
	drawPicture()	23
	drawPosText()	16
	drawTextOnPath()	16
	drawVertices()	✗
	setDrawFilter()	16
	clipPath()	18
	clipRegion()	18
	clipRect(Region.Op.XOR)	18
	clipRect(Region.Op.Difference)	18
	clipRect(Region.Op.ReverseDifference)	18
	clipRect() with rotation/perspective	18
	drawArc()	21
	drawRoundRect()	21
	saveLayer() with RectF dimensions	21
	saveLayer() with float dimensions	21
	saveLayerAlpha() with RectF dimensions	21
	saveLayerAlpha() with float dimensions	21

	Paint
	
	setAntiAlias() (for text)	18
	setAntiAlias() (for lines)	16
	setFilterBitmap()	17
	setLinearText()	✗
	setMaskFilter()	✗
	setPathEffect() (for lines)	✗
	setRasterizer()	✗
	setShadowLayer() (other than text)	✗
	setStrokeCap() (for lines)	18
	setStrokeCap() (for points)	19
	setSubpixelText()	✗
	getFontFeatureSettings()	21
	isElegantTextHeight()	21
	isElegantTextHeight()	21
	setFontFeatureSettings()	21
	setLetterSpacing()	21
	Xfermode
	AvoidXfermode	✗
	PixelXorXfermode	✗
	PorterDuff.Mode.DARKEN (framebuffer)	✗
	PorterDuff.Mode.LIGHTEN (framebuffer)	✗
	PorterDuff.Mode.OVERLAY (framebuffer)	✗
	Shader
	ComposeShader inside ComposeShader	✗
	Same type shaders inside ComposeShader	✗
	Local matrix on ComposeShader	18
	Canvas Scaling
	
The hardware accelerated 2D rendering pipeline was built first to support unscaled drawing, with some drawing operations degrading quality significantly at higher scale values. These operations are implemented as textures drawn at scale 1.0, transformed by the GPU. In API level <17, using these operations will result in scaling artifacts increasing with scale.
	
The following table shows when implementation was changed to correctly handle large scales:

	Drawing operation to be scaled	First supported API level
	drawText()	18
	drawPosText()	✗
	drawTextOnPath()	✗
	Simple Shapes*	17
	Complex Shapes*	✗
	drawPath()	✗
	Shadow layer	✗


#### LAYER_TYPE_SOFTWARE会加大内存占用

从Android3.0 (API level11)开始，你对何时以及如何通过View.setLayerType()方法来使用layer有了更多的控制能力．此方法有两个参数：你想使用的layer的类型和一个可选的Paint对象，这个对象描述了layer应被如何组合．你可以使用Paint参数来应用颜色过滤，或指定混合模式或不透明度到一个layer．view可以使用以下三个类型之一：
• LAYER_TYPE_NONE:view按一般方式绘制，不使用离屏缓冲．这是默认的行为．
• LAYER_TYPE_SOFTWARE:view被绘制到一个bitmap中．
• LAYER_TYPE_HARDWARE:如果应用被硬加速了，view会被绘制到一个硬件纹理中．如果应用没被硬加速，此类型的layer的行为同于LAYER_TYPE_SOFTWARE．

 

#### 参考文档

[目录视图摘要视图订阅Android——硬件加速（Hardware Acceleration）](http://blog.csdn.net/xplee0576/article/details/25485339)

[Hardware Acceleration](http://developer.android.com/intl/zh-cn/guide/topics/graphics/hardware-accel.html#unsupported)