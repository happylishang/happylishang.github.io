---
layout: default
title: 状态栏与窗口管理系统：沉浸式的实现原理   
category: Android

---
 
实现Activity布局及全屏的时候，经常会有这样一个疑问：状态栏属于Activity的管理范畴吗？如果不归Activity管理，归谁管理呢？本篇就状态栏的实现及管理分析一下，并且针对我们的沉浸式来分析一下它的用法。对于平板与手机来说，两种实现是不同的，本文只针对手机。

	StatusBarManagerService.java
	PhoneWindow.java
	PhoneStatusBar.java
	
	<string name="config_statusBarComponent" translatable="false">com.android.systemui.statusbar.phone.PhoneStatusBar</string>
	
	    private void addStatusBarWindow() {
        // Put up the view
        final int height = getStatusBarHeight();

        // Now that the status bar window encompasses the sliding panel and its
        // translucent backdrop, the entire thing is made TRANSLUCENT and is
        // hardware-accelerated.
        final WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                height,
                WindowManager.LayoutParams.TYPE_STATUS_BAR,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                    | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING
                    | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH,
                PixelFormat.TRANSLUCENT);

        lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;

        lp.gravity = getStatusBarGravity();
        lp.setTitle("StatusBar");
        lp.packageName = mContext.getPackageName();
        makeStatusBarView();
        mWindowManager.addView(mStatusBarWindow, lp);
    }

其实动源码很容易看出就是利用WMS的addView去添加窗口，当然绘制还是在本地，只是管理交给WMS，一定要记住所有View的绘制都是在本地，WMS只负责管理WIndow，

窗口的大小是可以改变的，比如状态栏，实现的时候有一个高度，但是下拉显示的时候，会赋予全屏的高度。

# 没有Activity就不能显示View吗，Service可以显示View并更新View吗？当然可以
# 状态栏的位置处于很高层次，在一般视图的上面

对于Activity的内容，并没有限制，只是显示的位置，是同主题及状态栏有个陪着，或者说有个便宜，如果没有ActionBar，会怎么样呢

# fitSystemWindow只会让内容下移一个状态栏的距离，padding，不是margin的作用

# 不同的根布局

没有ActionBar

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
	    android:orientation="vertical"
	    android:fitsSystemWindows="true">
	    <!-- Popout bar for action modes -->
	    <ViewStub android:id="@+id/action_mode_bar_stub"
	              android:inflatedId="@+id/action_mode_bar"
	              android:layout="@layout/action_mode_bar"
	              android:layout_width="match_parent"
	              android:layout_height="wrap_content" />
	    <FrameLayout
	        android:layout_width="match_parent" 
	        android:layout_height="?android:attr/windowTitleSize"
	        style="?android:attr/windowTitleBackgroundStyle">
	        <TextView android:id="@android:id/title" 
	            style="?android:attr/windowTitleStyle"
	            android:background="@null"
	            android:fadingEdge="horizontal"
	            android:gravity="center_vertical"
	            android:layout_width="match_parent"
	            android:layout_height="match_parent" />
	    </FrameLayout>
	    <FrameLayout android:id="@android:id/content"
	        android:layout_width="match_parent" 
	        android:layout_height="0dip"
	        android:layout_weight="1"
	        android:foregroundGravity="fill_horizontal|top"
	        android:foreground="?android:attr/windowContentOverlay" />
	</LinearLayout>



含有ActionBar


	<com.android.internal.widget.ActionBarOverlayLayout
	    xmlns:android="http://schemas.android.com/apk/res/android"
	    android:id="@+id/action_bar_overlay_layout"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent"
	    android:splitMotionEvents="false">
	    <FrameLayout android:id="@android:id/content"
	        android:layout_width="match_parent"
	        android:layout_height="match_parent" />
	    <LinearLayout android:id="@+id/top_action_bar"
	                  android:layout_width="match_parent"
	                  android:layout_height="wrap_content">
	        <com.android.internal.widget.ActionBarContainer android:id="@+id/action_bar_container"
	            android:layout_width="match_parent"
	            android:layout_height="wrap_content"
	            android:layout_alignParentTop="true"
	            style="?android:attr/actionBarStyle"
	            android:gravity="top">
	            <com.android.internal.widget.ActionBarView
	                android:id="@+id/action_bar"
	                android:layout_width="match_parent"
	                android:layout_height="wrap_content"
	                style="?android:attr/actionBarStyle" />
	            <com.android.internal.widget.ActionBarContextView
	                android:id="@+id/action_context_bar"
	                android:layout_width="match_parent"
	                android:layout_height="wrap_content"
	                android:visibility="gone"
	                style="?android:attr/actionModeStyle" />
	        </com.android.internal.widget.ActionBarContainer>
	        <ImageView android:src="?android:attr/windowContentOverlay"
	                   android:scaleType="fitXY"
	                   android:layout_width="match_parent"
	                   android:layout_height="wrap_content" />
	    </LinearLayout>
	    <com.android.internal.widget.ActionBarContainer android:id="@+id/split_action_bar"
	                  android:layout_width="match_parent"
	                  android:layout_height="wrap_content"
	                  style="?android:attr/actionBarSplitStyle"
	                  android:visibility="gone"
	                  android:gravity="center"/>
	</com.android.internal.widget.ActionBarOverlayLayout>


看看如何定义根布局DecorView的子View

			 int layoutResource;
	        int features = getLocalFeatures();
	        // System.out.println("Features: 0x" + Integer.toHexString(features));
	        if ((features & ((1 << FEATURE_LEFT_ICON) | (1 << FEATURE_RIGHT_ICON))) != 0) {
	            if (mIsFloating) {
	                TypedValue res = new TypedValue();
	                getContext().getTheme().resolveAttribute(
	                        com.android.internal.R.attr.dialogTitleIconsDecorLayout, res, true);
	                layoutResource = res.resourceId;
	            } else {
	                layoutResource = com.android.internal.R.layout.screen_title_icons;
	            }
	            // XXX Remove this once action bar supports these features.
	            removeFeature(FEATURE_ACTION_BAR);
	            // System.out.println("Title Icons!");
	        } else if ((features & ((1 << FEATURE_PROGRESS) | (1 << FEATURE_INDETERMINATE_PROGRESS))) != 0
	                && (features & (1 << FEATURE_ACTION_BAR)) == 0) {
	            // Special case for a window with only a progress bar (and title).
	            // XXX Need to have a no-title version of embedded windows.
	            layoutResource = com.android.internal.R.layout.screen_progress;
	            // System.out.println("Progress!");
	        } else if ((features & (1 << FEATURE_CUSTOM_TITLE)) != 0) {
	            // Special case for a window with a custom title.
	            // If the window is floating, we need a dialog layout
	            if (mIsFloating) {
	                TypedValue res = new TypedValue();
	                getContext().getTheme().resolveAttribute(
	                        com.android.internal.R.attr.dialogCustomTitleDecorLayout, res, true);
	                layoutResource = res.resourceId;
	            } else {
	                layoutResource = com.android.internal.R.layout.screen_custom_title;
	            }
	            // XXX Remove this once action bar supports these features.
	            removeFeature(FEATURE_ACTION_BAR);
	        } else if ((features & (1 << FEATURE_NO_TITLE)) == 0) {
	            // If no other features and not embedded, only need a title.
	            // If the window is floating, we need a dialog layout
	            if (mIsFloating) {
	                TypedValue res = new TypedValue();
	                getContext().getTheme().resolveAttribute(
	                        com.android.internal.R.attr.dialogTitleDecorLayout, res, true);
	                layoutResource = res.resourceId;
	            } else if ((features & (1 << FEATURE_ACTION_BAR)) != 0) {
	                layoutResource = com.android.internal.R.layout.screen_action_bar;
	            } else {
	                layoutResource = com.android.internal.R.layout.screen_title;
	            }
	            // System.out.println("Title!");
	        } else if ((features & (1 << FEATURE_ACTION_MODE_OVERLAY)) != 0) {
	            layoutResource = com.android.internal.R.layout.screen_simple_overlay_action_mode;
	        } else {
	            // Embedded, so no decoration is needed.
	            layoutResource = com.android.internal.R.layout.screen_simple;
	            // System.out.println("Simple!");
	        }
        mDecor.startChanging();
        View in = mLayoutInflater.inflate(layoutResource, null);
        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));


# 推荐不使用ActionBar，全部自定义

