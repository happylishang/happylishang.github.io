---
layout: post
title: 全屏、沉浸式、系统UI原理分析：全方位控制“沉浸式”的实现
category: Android

--- 

目录

> 状体栏颜色设置原理    
> 导航栏颜色设置原理   
> fitSystemWindow原理   
> View消费或者DecorView的消费   
> window属性的配置影响   
 

 
前言：首先需要明确，状态栏与导航栏属于SystemUi的管理范畴，虽然我们现实界面的UI会受到SystemUi的影响，但是，我们并没有直接操纵SystemUI的权限与必要。比如更改状态栏的颜色、导航栏的颜色，其实还是操作自己的View，更改UI。你可以这么理解：状态栏与导航栏拥有自己独立的窗口，而且这两个窗口的优先级较高，会悬浮在所有窗口之上，可以把系统自身的状态栏与导航栏看做全透明的，看起来之所有会有背景颜色，是因为下层显示界面在被状态栏与导航栏覆盖的区域添加了颜色，通过SurfaceFlinger的图层混合，看起来就好像状态栏、导航栏自身有了背景色，不信看一下一个普通的Activity所对应的Surface（或者说Window也可以）。

    type   |  handle  | hint | flag | tr | blnd |   format    |     source crop (l,t,r,b)      |          frame         | name 
-----------+----------+------+------+----+------+-------------+--------------------------------+------------------------+------
       HWC | b66d63c0 | 0002 | 0000 | 00 | 0100 | RGBA_8888   |    0.0,    0.0, 1080.0, 1920.0 |    0,    0, 1080, 1920 | XXXXActivity
       HWC | b66d6550 | 0002 | 0000 | 00 | 0105 | RGBA_8888   |    0.0,    0.0, 1080.0,   72.0 |    0,    0, 1080,   72 | StatusBar
       HWC | b66d6690 | 0002 | 0000 | 00 | 0105 | RGBA_8888   |    0.0,    0.0, 1080.0,  144.0 |    0, 1776, 1080, 1920 | NavigationBar
 FB TARGET | b6a51c10 | 0000 | 0000 | 00 | 0105 | RGBA_8888   |    0.0,    0.0, 1080.0, 1920.0 |    0,    0, 1080, 1920 | HWC_FRAMEBUFFER_TARGET

*  第一个XXXXActivity，大小是屏幕大小
*  第二个状态栏StatusBar，大小对应顶部那一条
*  第三个是底部虚拟导航栏NavigationBar，大小对应底部那一条
*  HWC_FRAMEBUFFER_TARGET：是合成的目标Layer

从上表可以看出，虽然我们只展示了一个Activity，但是同时会有StatusBar、NavigationBar、XXXXActivity可以看出Activity是在状态栏与导航栏下面的，被覆盖了。 它们共同参与显示界面的合成，但是，StatusBar、NavigationBar明显不是属于APP自身UI管理的范畴，下面就来分析一下，APP层的API如何影响SystemUI的显示的，并一步步解开所谓沉浸式与全屏的原理，首先看一下如何更改状态栏颜色。

# 更新状态栏颜色原理

假设当前的场景是在Activity中：

    getWindow().setStatusBarColor(Color.TRANSPARENT);

其实这里调用的是PhoneWindow的setStatusBarColor函数，无论是Activity还是Dialog都是被抽象成PhoneWindow：

    @Override
    public void setStatusBarColor(int color) {
        mStatusBarColor = color;
        mForcedStatusBarColor = true;
        if (mDecor != null) {
            mDecor.updateColorViews(null, false /* animate */);
        }
    }
    
可以看到最终调用的是DecorView的updateColorViews函数，DecorView是属于Activity的内部对象，也就说，更新的对象从所谓的Window进入到了Activity自身的布局视图中，接着看DecorView，注意这里只关注更改颜色

     private WindowInsets updateColorViews(WindowInsets insets, boolean animate) {
            WindowManager.LayoutParams attrs = getAttributes();
            int sysUiVisibility = attrs.systemUiVisibility | getWindowSystemUiVisibility();

            if (!mIsFloating && ActivityManager.isHighEndGfx()) {
                boolean disallowAnimate = !isLaidOut();
                disallowAnimate |= ((mLastWindowFlags ^ attrs.flags)
                        & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;
                mLastWindowFlags = attrs.flags;
                ...
                boolean statusBarNeedsRightInset = navBarToRightEdge
                        && mNavigationColorViewState.present;
                int statusBarRightInset = statusBarNeedsRightInset ? mLastRightInset : 0;
                <!--更新Color-->
                updateColorViewInt(mStatusColorViewState, sysUiVisibility, mStatusBarColor,
                        mLastTopInset, false /* matchVertical */, statusBarRightInset,
                        animate && !disallowAnimate);
            }
            ...
        }

这里mStatusColorViewState其实就代表StatusBar的背景颜色对象，主要属性包括显示的条件以及颜色值：

        private final ColorViewState mStatusColorViewState = new ColorViewState(
                SYSTEM_UI_FLAG_FULLSCREEN, FLAG_TRANSLUCENT_STATUS,
                Gravity.TOP,
                Gravity.LEFT,
                STATUS_BAR_BACKGROUND_TRANSITION_NAME,
                com.android.internal.R.id.statusBarBackground,
                FLAG_FULLSCREEN);
                
当当前对应Window的SystemUi设置了SYSTEM_UI_FLAG_FULLSCREEN后，就说明这个时候会隐藏状态栏，那就不在需要为状态栏设置背景，因此**DecorView决定了是不是要显示状态栏底部颜色背景**。
                
	  private void updateColorViewInt(final ColorViewState state, int sysUiVis, int color,
	                int size, boolean verticalBar, int rightMargin, boolean animate) {
	                <!--关键点1 条件1-->
	            state.present = size > 0 && (sysUiVis & state.systemUiHideFlag) == 0
	                    && (getAttributes().flags & state.hideWindowFlag) == 0
	                    && (getAttributes().flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;
	               <!--关键点2 条件2-->
	            boolean show = state.present
	                    && (color & Color.BLACK) != 0
	                    && (getAttributes().flags & state.translucentFlag) == 0;
	
	            boolean visibilityChanged = false;
	            View view = state.view;
	
	            int resolvedHeight = verticalBar ? LayoutParams.MATCH_PARENT : size;
	            int resolvedWidth = verticalBar ? size : LayoutParams.MATCH_PARENT;
	            int resolvedGravity = verticalBar ? state.horizontalGravity : state.verticalGravity;
	
	            if (view == null) {
	                if (show) {
	                    state.view = view = new View(mContext);
	                    view.setBackgroundColor(color);
	                    view.setTransitionName(state.transitionName);
	                    view.setId(state.id);
	                    visibilityChanged = true;
	                    view.setVisibility(INVISIBLE);
	                    state.targetVisibility = VISIBLE;
				<!--关键点3-->
	                    LayoutParams lp = new LayoutParams(resolvedWidth, resolvedHeight,
	                            resolvedGravity);
	                    lp.rightMargin = rightMargin;
	                    addView(view, lp);
	                    updateColorViewTranslations();
	                }
	            } else {
	                int vis = show ? VISIBLE : INVISIBLE;
	                visibilityChanged = state.targetVisibility != vis;
	                state.targetVisibility = vis;
	                if (show) {
	                    LayoutParams lp = (LayoutParams) view.getLayoutParams();
	                    if (lp.height != resolvedHeight || lp.width != resolvedWidth
	                            || lp.gravity != resolvedGravity || lp.rightMargin != rightMargin) {
	                        lp.height = resolvedHeight;
	                        lp.width = resolvedWidth;
	                        lp.gravity = resolvedGravity;
	                        lp.rightMargin = rightMargin;
	                        view.setLayoutParams(lp);
	                    }
	                    view.setBackgroundColor(color);
	                }
	            }
	          ...
	        }
	        
首先看下关键点1跟2 ，这里是根据SystemUI的配置决定是否显示状态栏背景颜色，如果状态栏都不显示，那就没必要显示背景色了，其次，如果状态栏显示，但是为状态栏设置的背景是透明色，那也没必要添加背景颜色，即不满足(color & Color.BLACK) != 0。最后看一下translucentFlag，默认情况下，状态栏背景色与translucent半透明效果互斥，半透明就统一用半透明颜色，不会再添加额外颜色。再来看关键点3，其实很简单，就是往DecorView上添加一个View，由于原则上说DecorView也是一个FrameLayout，其实就是盖在上面的效果。 可以看一下布局
 
*  	 图1 设置颜色，但是没有设置Flag_FULL_SCREEN 
*   图2 设置颜色，但是设置了Flag_FULL_SCREEN 
*   图3 设置透明，但是没有设置Flag_FULL_SCREEN 
   
以上是DecorView对状态栏的添加机制，其实就   
 
# 更新导航栏颜色原理                  

更新导航栏颜色的原理同更新状态栏的原理几乎完全一致，如下代码

    @Override
    public void setNavigationBarColor(int color) {
        mNavigationBarColor = color;
        mForcedNavigationBarColor = true;
        if (mDecor != null) {
            mDecor.updateColorViews(null, false /* animate */);
        }
    }
    
只不过在DecorView进行颜色更新的时候，传递的对象是 mNavigationColorViewState

    private final ColorViewState mNavigationColorViewState = new ColorViewState(
            SYSTEM_UI_FLAG_HIDE_NAVIGATION, FLAG_TRANSLUCENT_NAVIGATION,
            Gravity.BOTTOM, Gravity.RIGHT,
            Window.NAVIGATION_BAR_BACKGROUND_TRANSITION_NAME,
            com.android.internal.R.id.navigationBarBackground,
            0 /* hideWindowFlag */);

同样mNavigationColorViewState也有显示的条件，如果设置了SYSTEM_UI_FLAG_HIDE_NAVIGATION、或者半透明、或者颜色为透明色，那同样也不需要为导航栏添加背景色，具体不再重复。**改变状体栏及导航栏的颜色的本质是往DecorView中添加有颜色的View， 并放在状态栏及导航栏下面**。

以上解决了设置状态栏颜色、以及设置了颜色是否会显示的问题（也可能动态显示）的问题，总结出来就是一句话：只要不设置隐藏，设置颜色就会有效。但是当设置状态栏与导航栏为透明色的时候：即想要沉浸式体验的时候，颜色就不在被绘制，但是DecorView的内容绘制区域并未扩展到状态栏、或者导航栏下面（TRANSLUCENT半透明效果除外（5.0之上，一般不会有TRANSLUCENT功能）），想要解决这个问题，就牵扯到下面的fitsystemwindow的处理。

# fitsystemwindow的意义

fitSystemWindow主要配合状态栏及导航栏的设置，让DecorView的内容区域能够延伸到系统UI下方，达到全屏、沉浸等不同体验效果的设置。先看下效果图，及布局图：

![屏幕快照 2017-06-16 下午3.08.18.png](http://upload-images.jianshu.io/upload_images/1460468-1329b2cbfac91fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![屏幕快照 2017-06-16 上午11.37.54.png](http://upload-images.jianshu.io/upload_images/1460468-d3b23c5c4eb8130e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![屏幕快照 2017-06-15 下午9.01.37.png](http://upload-images.jianshu.io/upload_images/1460468-f9ffb5d78460e51c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![屏幕快照 2017-06-15 下午8.57.05.png](http://upload-images.jianshu.io/upload_images/1460468-322791c2b4c57020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


*  状态栏（导航栏背景）的显示隐藏
*  导航栏（状态栏背景）的显示隐藏
*  ViewRootImpl中的onApply覆盖 （DecorView）

 
## DecorView级别的fitSystemWindow消费

默认样式下，Activity的状态栏是有颜色的，那么如果内容显示扩展到状态栏下方，那么一定会被覆盖掉，系统默认的实现是在系统级别的根布局的位置给了个padding，那么用户自己的UI视图就不会被覆盖。但是设置透明之后，默认就会看到内容区域在状态栏下方有一片空白，这种体验肯定不要，比如图片浏览，我们希望图片能延伸到状体栏下方，这时候，就要把哪部分空白给利用掉。首先分析下，默认情况下，为什么会有顶部的空白来适配状态栏呢？

我们看下一默认情况下系统的跟布局属性，里面有个关键点     android:fitsSystemWindows="true"

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent"
	    <!--关键点1-->
	    android:fitsSystemWindows="true"
	    android:orientation="vertical">
	    <ViewStub android:id="@+id/action_mode_bar_stub"
	              android:inflatedId="@+id/action_mode_bar"
	              android:layout="@layout/action_mode_bar"
	              android:layout_width="match_parent"
	              android:layout_height="wrap_content"
	              android:theme="?attr/actionBarTheme" />
	    <FrameLayout
	         android:id="@android:id/content"
	         android:layout_width="match_parent"
	         android:layout_height="match_parent"
	         android:foregroundInsidePadding="false"
	         android:foregroundGravity="fill_horizontal|top"
	         android:foreground="?android:attr/windowContentOverlay" />
	</LinearLayout>
	
**android:fitsSystemWindows这个属性是系统默认有个状态栏padding的关键**，为什么这样呢？我们看下ViewRootImpl的源码，ViewRootImpl在进行布局与绘制的时候会选择性调用dispatchApplyInsets

	 private void performTraversals() {
	          ...
		 host.fitSystemWindows(mFitSystemWindowsInsets);
	 

    void dispatchApplyInsets(View host) {
        host.dispatchApplyWindowInsets(getWindowInsets(true /* forceConstruct */));
    }

进而进入DecorView的相应处理逻辑最终会回调View的onApplyWindowInsets函数，DecorView重写了该函数：

调用流程图：

    @Override
    public WindowInsets onApplyWindowInsets(WindowInsets insets) {
        final WindowManager.LayoutParams attrs = mWindow.getAttributes();
        mFloatingInsets.setEmpty();
        if ((attrs.flags & FLAG_LAYOUT_IN_SCREEN) == 0) {
            if (attrs.height == WindowManager.LayoutParams.WRAP_CONTENT) {
                mFloatingInsets.top = insets.getSystemWindowInsetTop();
                mFloatingInsets.bottom = insets.getSystemWindowInsetBottom();
                insets = insets.replaceSystemWindowInsets(insets.getSystemWindowInsetLeft(), 0,
                        insets.getSystemWindowInsetRight(), 0);
            }
            if (mWindow.getAttributes().width == WindowManager.LayoutParams.WRAP_CONTENT) {
                mFloatingInsets.left = insets.getSystemWindowInsetTop();
                mFloatingInsets.right = insets.getSystemWindowInsetBottom();
                insets = insets.replaceSystemWindowInsets(0, insets.getSystemWindowInsetTop(),
                        0, insets.getSystemWindowInsetBottom());
            }
        }
        mFrameOffsets.set(insets.getSystemWindowInsets());
        insets = updateColorViews(insets, true /* animate */);
        insets = updateStatusGuard(insets);
        updateNavigationGuard(insets);
        if (getForeground() != null) {
            drawableChanged();
        }
        return insets;
    }
  
可以看到最后还是调用DecorView的updateColorViews函数统一处理，不过首先这里我们关心的是关于fitSystemWindow的：

      private WindowInsets updateColorViews(WindowInsets insets, boolean animate) {
            WindowManager.LayoutParams attrs = getAttributes();
            int sysUiVisibility = attrs.systemUiVisibility | getWindowSystemUiVisibility();

            if (!mIsFloating && ActivityManager.isHighEndGfx()) {
            ...
 		<!--关键点1 ：6.0代码是否能够扩展到导航栏下面-->
 		
		 boolean consumingNavBar = (attrs.flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0
		                            && (sysUiVisibility & SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0
		                            && (sysUiVisibility & SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;

            int consumedRight = consumingNavBar ? mLastRightInset : 0;
            int consumedBottom = consumingNavBar ? mLastBottomInset : 0;
			<!--关键点1 ，可以看到，根布局会根据消耗的状况，来评估到底底部，右边部分margin多少，并设置进去-->
            if (mContentRoot != null
                    && mContentRoot.getLayoutParams() instanceof MarginLayoutParams) {
                MarginLayoutParams lp = (MarginLayoutParams) mContentRoot.getLayoutParams();
                if (lp.rightMargin != consumedRight || lp.bottomMargin != consumedBottom) {
                    lp.rightMargin = consumedRight;
                    lp.bottomMargin = consumedBottom;
                    mContentRoot.setLayoutParams(lp);
                   if (insets == null) {
                        // The insets have changed, but we're not currently in the process
                        // of dispatching them.
                        requestApplyInsets();
                    }
                }
                if (insets != null) {
                    insets = insets.replaceSystemWindowInsets(
                            insets.getSystemWindowInsetLeft(),
                            insets.getSystemWindowInsetTop(),
                            insets.getSystemWindowInsetRight() - consumedRight,
                            insets.getSystemWindowInsetBottom() - consumedBottom);
                }
            }

            if (insets != null) {
                insets = insets.consumeStableInsets();
            }
            return insets;	
            }
            
    mContentRoot.setLayoutParams(lp);

可以看出内容根布局布局文件中，对于底部的边距是采用了Margin的方式。底部的insets被系统布局消费掉的条件如下：

* (sysUiVisibility & SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0，没强制要求内容扩展到导航栏下方
* (attrs.flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0 必须绘制系统吧背景
* (sysUiVisibility & SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 没有隐藏导航栏 

满足以上三点，DecorView就会消费掉，利用Margin的方式，一般默认情况下都是这样

			 boolean consumingNavBar = (attrs.flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0
		                            && (sysUiVisibility & SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0
		                            && (sysUiVisibility & SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;

但是如果设置了SYSTEM_UI_FLAG_HIDE_NAVIGATION，跟布局的SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION就会生效，这样DecorView的根布局会消费掉。自己设置padding，而不是DecorView设置margin的方式，记住，消费了就是消费了，如果消费完了，就不能再消费了。

![默认的margin](http://upload-images.jianshu.io/upload_images/1460468-d31431cdd17b791b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

6.0源码中，DecorView没有对状态栏进行消费，状态栏的消费都留给了DecorView子布局及孙子辈布局，那接着看非DecorView系统布局：

## 系统布局级别（非DecorView）的fitSystemWindow消费

看View中源码：fitSystemWindowsInt

	  protected boolean fitSystemWindows(Rect insets) {
	
	
	        if ((mPrivateFlags3 & PFLAG3_APPLYING_INSETS) == 0) {
	            if (insets == null) {
	                return false;
	            }
	            // If we're not in the process of dispatching the newer apply insets call,
	            // that means we're not in the compatibility path. Dispatch into the newer
	            // apply insets path and take things from there.
	            try {
	            	// 防止死循环
	                mPrivateFlags3 |= PFLAG3_FITTING_SYSTEM_WINDOWS;
	                return dispatchApplyWindowInsets(new WindowInsets(insets)).isConsumed();
	            } finally {
	                mPrivateFlags3 &= ~PFLAG3_FITTING_SYSTEM_WINDOWS;
	            }
	        } else {
	            // We're being called from the newer apply insets path.
	            // Perform the standard fallback behavior.
	            return fitSystemWindowsInt(insets);
	        }
	    }

    private boolean fitSystemWindowsInt(Rect insets) {
     		<!--关键点1-->
        if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
            mUserPaddingStart = UNDEFINED_PADDING;
            mUserPaddingEnd = UNDEFINED_PADDING;
            Rect localInsets = sThreadLocal.get();
            if (localInsets == null) {
                localInsets = new Rect();
                sThreadLocal.set(localInsets);
            }
           <!--关键点2-->
            boolean res = computeFitSystemWindows(insets, localInsets);
            mUserPaddingLeftInitial = localInsets.left;
            mUserPaddingRightInitial = localInsets.right;
            internalSetPadding(localInsets.left, localInsets.top,
                    localInsets.right, localInsets.bottom);
            return res;
        }
        return false;
    }
    
先看关键点1，如果View设置了FITS_SYSTEM_WINDOWS，就通过关键点2 computeFitSystemWindows去计算是否能消费，
	
	protected boolean computeFitSystemWindows(Rect inoutInsets, Rect outLocalInsets) {
	        
	        // 这里已经是满足 FITS_SYSTEM_WINDOWS 标志位
			// OPTIONAL_FITS_SYSTEM_WINDOWS 代表着是系统View 
			// SYSTEM_UI_LAYOUT_FLAGS 代表着全屏    SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION| SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
	     	//  如果是普通View可以直接消费，如果是系统View，要看看是不是设置了全屏      
	
			// 非系统的UI可以，系统UI未设置全屏可以
			// 所有View公用mAttachInfo.mSystemUiVisibility
	
	        if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0
	                || mAttachInfo == null
	                || ((mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0
	                        && !mAttachInfo.mOverscanRequested)) {
	            outLocalInsets.set(inoutInsets);
	            inoutInsets.set(0, 0, 0, 0);
	            return true;
	        } else {
	
	            // The application wants to take care of fitting system window for
	            // the content...  however we still need to take care of any overscan here.
	            final Rect overscan = mAttachInfo.mOverscanInsets;
	            // 看看整体是不是有消耗，或者说系统上有消耗
	            // 整体上消耗 mAttachInfo.mOverscanInsets这个怎么算的 ？？
	            // 貌似 DecorView只会计算底部的padding，顶部的padding都是留给Content计算，
	            // 所以顶部如果设置了一定不显示，但是底部可以

	            outLocalInsets.set(overscan);
	            inoutInsets.left -= overscan.left;
	            inoutInsets.top -= overscan.top;
	            inoutInsets.right -= overscan.right;
	            inoutInsets.bottom -= overscan.bottom;
	            return false;
	        }
	    }
 
*  mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS 代表是用户的UI
*  mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS 没设置全屏之类的参数，因此没设置全屏，但是只是隐藏了SysytemUI的的情况下，会被ContenGroup给消费掉。

## 用户布局级别的fitSystemWindow消费

如果以上都没消费掉，就走到了用户级别的消费，这里也分不同的情况，如果设置了

	  <item name="android:fitsSystemWindows">true</item>

那就默认，必定有一个未设置fitsSystemWindows的第一个布局消费掉，否则遵守View默认的消费逻辑，第一个FitSystemWindow=true的布局消费掉，设置自己的padding。


# 总结

注意分成两部分：

* 颜色的设置+状态栏与导航栏的隐藏（这两个才有关系）
* 隐藏了，一定不消费
* 默认的DecorView消费导航栏，利用其内部Content的margin，padding，都不是Decorview层面的消费方式。
* fitsysytemwindow与UI的content的扩展，如果设置了扩展，那么一定留给子View消费


# 如何将布局延伸到状态栏下方？

 
fitSystemWindow  及UI_HIDE的控制其实主要针对 Padding  DecorView的Padding（系统级别的状体栏，非系统的底部）

全屏:UI_HIDE_LAYOUT ：将content可绘制的内容区扩展到整个屏幕

沉浸式？ 半透明 是4.4提出的，5.0之后，不推荐使用，因为5.0之后，所有的一切颜色，透明高难度，绘制区域都是可控的，完全兼容4.4的功能。并且，使用半透明头5。0之后的功能互斥

比如 我该如何才能全屏显示呢？

 
如果了解WMS的知识，就会知道，其实Surface的展示可以状体栏窗口+导航栏窗口+内容显示区域View窗口，Activity其实也只是View的容器，内容显示区域View其实是在导航及状态栏下面的，默认导航栏的优先级很高，浮在上面，Activity的内容都在下面，如果是全屏的并不是跟状态栏拼接，而是被覆盖，只是有背景，才导致了看不到，但是可以通过代码，设置导航栏及状态栏颜色，让底部可见，

 

    <style name="AppTheme.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="android:windowDrawsSystemBarBackgrounds">true</item>
        <item name="android:windowTranslucentStatus">true</item>
        <item name="android:statusBarColor">@color/red</item>
        <item name="android:navigationBarColor">@color/red</item>
    </style>
    
 不能要半透明，android:windowTranslucentStatus，才能设置顶部statusbar的颜色，
 
 android:fitsSystemWindows="false"  android:fitsSystemWindows="true"在哪层消费呢，就在哪层起作用，Layout内部的作用是顶部padding，但是底部是margin
 
 
#  windowTranslucentStatus statusBarColor不能同时生效

 21版本以上的透明系统栏需要使用android:statusBarColor = "@android:color/transparent"来实现；这里android:windowTranslucentStatus肯定是为false的，因为这两个属性是不能同时生效的。但是由于android:windowTranslucentStatus属性的禁用，状态栏将不再会是浮在我们的window上。没关系，我们可以通过下面的方法达到一样的效果：

getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
其实设置android:windowTranslucentStatus属性时，正是系统帮我们设置了上面的Flag；上面我们在DecorView上调用这个方法，但其实可以在任何一个可见的View上进行调用，效果是一样的。

**：‘windowTranslucentStatus’和‘windowTranslucentNavigation’设置为true后就再设置‘statusBarColor’和‘navigationBarColor’就没有效果了。**

整个屏幕透明 ：配合方式

        //使得布局延伸到状态栏和导航栏区域
        window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
        //透明状态栏/导航栏
        window.setStatusBarColor(Color.TRANSPARENT);
        window.setNavigationBarColor(Color.TRANSPARENT);
        //这样的效果跟上述的主题设置效果类似
        
        纯代码实现
    
        <style name="AppTheme.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="android:windowDrawsSystemBarBackgrounds">true</item>
        <item name="android:statusBarColor">@color/transparent</item>
        <item name="android:windowTranslucentStatus">false</item>
        <item name="android:navigationBarColor">@color/transparent</item>
        <item name="android:windowTranslucentNavigation">false</item>
	    </style>
    
    
上面的可以让状态栏底部导航栏透明，如果     android:fitsSystemWindows="false" 内容充满真个屏幕  ，如果    android:fitsSystemWindows="true" 内容预留出顶部与底部，

#  5.0的不用android:windowTranslucentStatus  
 
 android:windowTranslucentNavigation，这个是半透明的效果，不是全透明的，不好控制，颜色要自己控制的话，就在DecorView中消除这个影响。
 
实现Activity布局及全屏的时候，经常会有这样一个疑问：状态栏属于Activity的管理范畴吗？如果不归Activity管理，归谁管理呢？本篇就状态栏的实现及管理分析一下，并且针对沉浸式的实现来分析。对于平板与手机来说，两种实现是不同的，本文只针对手机。几个问题

*  Activity默认是全屏的吗？
*  状态栏与导航栏设置透明的为何还有颜色，颜色是谁的颜色
*  fitsysytemWindow的作用
*  全屏的实现，顶部与底部
*  fitsysytemwindow的消费以及实现原理（顶部分padding底部的margin）



顶部状态栏透明

底部导航栏透明


以上几个问题可能比较模糊

	StatusBarManagerService.java
	PhoneWindow.java
	PhoneStatusBar.java
	
	<string name="config_statusBarComponent" translatable="false">com.android.systemui.statusbar.phone.PhoneStatusBar</string>
	
	    private void addStatusBarWindow() {
        final int height = getStatusBarHeight();
        final WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                height,
                WindowManager.LayoutParams.TYPE_STATUS_BAR,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                    | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING
                    | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH,
                PixelFormat.TRANSLUCENT);

        lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;

        lp.gravity = getStatusBarGravity();
        lp.setTitle("StatusBar");
        lp.packageName = mContext.getPackageName();
        makeStatusBarView();
        mWindowManager.addView(mStatusBarWindow, lp);
    }

其实动源码很容易看出就是利用WMS的addView去添加窗口，当然绘制还是在本地，只是管理交给WMS，一定要记住所有View的绘制都是在本地，WMS只负责管理Window显示顺序及计算校准窗口大小

窗口的大小是可以改变的，比如状态栏，实现的时候有一个高度，但是**下拉显示的时候，会赋予全屏的高度**。

# 没有Activity就不能显示View吗，Service可以显示View并更新View吗？当然可以
 
 


 
# 状态栏的位置处于很高层次，在一般视图的上面

对于Activity的内容，并没有限制，只是显示的位置，是同主题及状态栏有个陪着，或者说有个便宜，如果没有ActionBar，会怎么样呢

# fitSystemWindow只会让内容下移一个状态栏的距离，padding，不是margin的作用

# 不同的根布局

没有ActionBar

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
	    android:orientation="vertical"
	    android:fitsSystemWindows="true">
	    <!-- Popout bar for action modes -->
	    <ViewStub android:id="@+id/action_mode_bar_stub"
	              android:inflatedId="@+id/action_mode_bar"
	              android:layout="@layout/action_mode_bar"
	              android:layout_width="match_parent"
	              android:layout_height="wrap_content" />
	    <FrameLayout
	        android:layout_width="match_parent" 
	        android:layout_height="?android:attr/windowTitleSize"
	        style="?android:attr/windowTitleBackgroundStyle">
	        <TextView android:id="@android:id/title" 
	            style="?android:attr/windowTitleStyle"
	            android:background="@null"
	            android:fadingEdge="horizontal"
	            android:gravity="center_vertical"
	            android:layout_width="match_parent"
	            android:layout_height="match_parent" />
	    </FrameLayout>
	    <FrameLayout android:id="@android:id/content"
	        android:layout_width="match_parent" 
	        android:layout_height="0dip"
	        android:layout_weight="1"
	        android:foregroundGravity="fill_horizontal|top"
	        android:foreground="?android:attr/windowContentOverlay" />
	</LinearLayout>



含有ActionBar

	<com.android.internal.widget.ActionBarOverlayLayout
	    xmlns:android="http://schemas.android.com/apk/res/android"
	    android:id="@+id/action_bar_overlay_layout"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent"
	    android:splitMotionEvents="false">
	    <FrameLayout android:id="@android:id/content"
	        android:layout_width="match_parent"
	        android:layout_height="match_parent" />
	    <LinearLayout android:id="@+id/top_action_bar"
	                  android:layout_width="match_parent"
	                  android:layout_height="wrap_content">
	        <com.android.internal.widget.ActionBarContainer android:id="@+id/action_bar_container"
	            android:layout_width="match_parent"
	            android:layout_height="wrap_content"
	            android:layout_alignParentTop="true"
	            style="?android:attr/actionBarStyle"
	            android:gravity="top">
	            <com.android.internal.widget.ActionBarView
	                android:id="@+id/action_bar"
	                android:layout_width="match_parent"
	                android:layout_height="wrap_content"
	                style="?android:attr/actionBarStyle" />
	            <com.android.internal.widget.ActionBarContextView
	                android:id="@+id/action_context_bar"
	                android:layout_width="match_parent"
	                android:layout_height="wrap_content"
	                android:visibility="gone"
	                style="?android:attr/actionModeStyle" />
	        </com.android.internal.widget.ActionBarContainer>
	        <ImageView android:src="?android:attr/windowContentOverlay"
	                   android:scaleType="fitXY"
	                   android:layout_width="match_parent"
	                   android:layout_height="wrap_content" />
	    </LinearLayout>
	    <com.android.internal.widget.ActionBarContainer android:id="@+id/split_action_bar"
	                  android:layout_width="match_parent"
	                  android:layout_height="wrap_content"
	                  style="?android:attr/actionBarSplitStyle"
	                  android:visibility="gone"
	                  android:gravity="center"/>
	</com.android.internal.widget.ActionBarOverlayLayout>


看看如何定义根布局DecorView的子View

			 int layoutResource;
	        int features = getLocalFeatures();
	        // System.out.println("Features: 0x" + Integer.toHexString(features));
	        if ((features & ((1 << FEATURE_LEFT_ICON) | (1 << FEATURE_RIGHT_ICON))) != 0) {
	            if (mIsFloating) {
	                TypedValue res = new TypedValue();
	                getContext().getTheme().resolveAttribute(
	                        com.android.internal.R.attr.dialogTitleIconsDecorLayout, res, true);
	                layoutResource = res.resourceId;
	            } else {
	                layoutResource = com.android.internal.R.layout.screen_title_icons;
	            }
	            // XXX Remove this once action bar supports these features.
	            removeFeature(FEATURE_ACTION_BAR);
	            // System.out.println("Title Icons!");
	        } else if ((features & ((1 << FEATURE_PROGRESS) | (1 << FEATURE_INDETERMINATE_PROGRESS))) != 0
	                && (features & (1 << FEATURE_ACTION_BAR)) == 0) {
	            // Special case for a window with only a progress bar (and title).
	            // XXX Need to have a no-title version of embedded windows.
	            layoutResource = com.android.internal.R.layout.screen_progress;
	            // System.out.println("Progress!");
	        } else if ((features & (1 << FEATURE_CUSTOM_TITLE)) != 0) {
	            // Special case for a window with a custom title.
	            // If the window is floating, we need a dialog layout
	            if (mIsFloating) {
	                TypedValue res = new TypedValue();
	                getContext().getTheme().resolveAttribute(
	                        com.android.internal.R.attr.dialogCustomTitleDecorLayout, res, true);
	                layoutResource = res.resourceId;
	            } else {
	                layoutResource = com.android.internal.R.layout.screen_custom_title;
	            }
	            // XXX Remove this once action bar supports these features.
	            removeFeature(FEATURE_ACTION_BAR);
	        } else if ((features & (1 << FEATURE_NO_TITLE)) == 0) {
	            // If no other features and not embedded, only need a title.
	            // If the window is floating, we need a dialog layout
	            if (mIsFloating) {
	                TypedValue res = new TypedValue();
	                getContext().getTheme().resolveAttribute(
	                        com.android.internal.R.attr.dialogTitleDecorLayout, res, true);
	                layoutResource = res.resourceId;
	            } else if ((features & (1 << FEATURE_ACTION_BAR)) != 0) {
	                layoutResource = com.android.internal.R.layout.screen_action_bar;
	            } else {
	                layoutResource = com.android.internal.R.layout.screen_title;
	            }
	            // System.out.println("Title!");
	        } else if ((features & (1 << FEATURE_ACTION_MODE_OVERLAY)) != 0) {
	            layoutResource = com.android.internal.R.layout.screen_simple_overlay_action_mode;
	        } else {
	            // Embedded, so no decoration is needed.
	            layoutResource = com.android.internal.R.layout.screen_simple;
	            // System.out.println("Simple!");
	        }
        mDecor.startChanging();
        View in = mLayoutInflater.inflate(layoutResource, null);
        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));


# 推荐不使用ActionBar，全部自定义


# 这里如何获取WindowInsets // mAttachInfo都是在relayout之后 ，设置及更新

contentInsets作为systemInsets


    /* package */ WindowInsets getWindowInsets(boolean forceConstruct) {
        if (mLastWindowInsets == null || forceConstruct) {
            mDispatchContentInsets.set(mAttachInfo.mContentInsets);
            mDispatchStableInsets.set(mAttachInfo.mStableInsets);
            Rect contentInsets = mDispatchContentInsets;
            Rect stableInsets = mDispatchStableInsets;
            // For dispatch we preserve old logic, but for direct requests from Views we allow to
            // immediately use pending insets.
            if (!forceConstruct
                    && (!mPendingContentInsets.equals(contentInsets) ||
                        !mPendingStableInsets.equals(stableInsets))) {
                contentInsets = mPendingContentInsets;
                stableInsets = mPendingStableInsets;
            }
            Rect outsets = mAttachInfo.mOutsets;
            if (outsets.left > 0 || outsets.top > 0 || outsets.right > 0 || outsets.bottom > 0) {
                contentInsets = new Rect(contentInsets.left + outsets.left,
                        contentInsets.top + outsets.top, contentInsets.right + outsets.right,
                        contentInsets.bottom + outsets.bottom);
            }
            mLastWindowInsets = new WindowInsets(contentInsets,
                    null /* windowDecorInsets */, stableInsets,
                    mContext.getResources().getConfiguration().isScreenRound());
        }
        return mLastWindowInsets;
    }
    
    
#  Service内部同样可以更新View   



        这段代码用来获得Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight。
        注意，Activity窗口当前的宽度和高度是保存ViewRoot类的成员变量mWinFrame中的。ViewRoot类的另外两个成员变量mWidth和mHeight也是用来描述Activity窗口当前的宽度和高度的，但是它们的值是由应用程序进程上一次主动请求WindowManagerService服务计算得到的，并且会一直保持不变到应用程序进程下一次再请求WindowManagerService服务来重新计算为止。Activity窗口的当前宽度和高度有时候是被WindowManagerService服务主动请求应用程序进程修改的，修改后的值就会保存在ViewRoot类的成员变量mWinFrame中，它们可能会与ViewRoot类的成员变量mWidth和mHeight的值不同。

        如果Activity窗口是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true，那么它的当前宽度desiredWindowWidth和当前高度desiredWindowHeight就等于屏幕的宽度和高度，否则的话，它的当前宽度desiredWindowWidth和当前高度desiredWindowHeight就等于保存在ViewRoot类的成员变量mWinFrame中的宽度和高度值。

        如果Activity窗口不是第一次被请求执行测量、布局和绘制操作，并且Activity窗口主动上一次请求WindowManagerService服务计算得到的宽度mWidth和高度mHeight不等于Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight，那么就说明Activity窗口的大小发生了变化，这时候变量windowResizesToFitContent的值就会被标记为true，以便接下来可以对Activity窗口的大小变化进行处理。

# 状态栏与跟底部导航栏显示与隐藏

fitSystemWindow只是针对Decorview或者View来进行设置的  ，Decorview 的setSysytemUiVIsbility，21版本之上不用用trannlactent效果，会覆盖状态栏设置的效果。


# // 看看这里，也许这里才是根本的mSystemUiVisibility 一个入口

    private int getImpliedSystemUiVisibility(WindowManager.LayoutParams params) {
        int vis = 0;

        // 很明显Translucent 与那种设置fit互斥
        // Translucent decor window flags imply stable system ui visibility.
        if ((params.flags & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) != 0) {
            vis |= View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
        }
        if ((params.flags & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) != 0) {
            vis |= View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;
        }
        return vis;
    }


// 这里牵扯到如何更新顶部状态与底部导航栏

// 这里牵扯到如何更新顶部状态与底部导航栏

    WindowInsets updateColorViews(WindowInsets insets, boolean animate) {
        WindowManager.LayoutParams attrs = mWindow.getAttributes();
        int sysUiVisibility = attrs.systemUiVisibility | getWindowSystemUiVisibility();

        if (!mWindow.mIsFloating && ActivityManager.isHighEndGfx()) {
            boolean disallowAnimate = !isLaidOut();
            disallowAnimate |= ((mLastWindowFlags ^ attrs.flags)
                    & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;
            mLastWindowFlags = attrs.flags;

            if (insets != null) {
                mLastTopInset = getColorViewTopInset(insets.getStableInsetTop(),
                        insets.getSystemWindowInsetTop());
                mLastBottomInset = getColorViewBottomInset(insets.getStableInsetBottom(),
                        insets.getSystemWindowInsetBottom());
                mLastRightInset = getColorViewRightInset(insets.getStableInsetRight(),
                        insets.getSystemWindowInsetRight());

                // Don't animate if the presence of stable insets has changed, because that
                // indicates that the window was either just added and received them for the
                // first time, or the window size or position has changed.
                boolean hasTopStableInset = insets.getStableInsetTop() != 0;
                disallowAnimate |= (hasTopStableInset != mLastHasTopStableInset);
                mLastHasTopStableInset = hasTopStableInset;

                boolean hasBottomStableInset = insets.getStableInsetBottom() != 0;
                disallowAnimate |= (hasBottomStableInset != mLastHasBottomStableInset);
                mLastHasBottomStableInset = hasBottomStableInset;

                boolean hasRightStableInset = insets.getStableInsetRight() != 0;
                disallowAnimate |= (hasRightStableInset != mLastHasRightStableInset);
                mLastHasRightStableInset = hasRightStableInset;
                mLastShouldAlwaysConsumeNavBar = insets.shouldAlwaysConsumeNavBar();
            }

            boolean navBarToRightEdge = isNavBarToRightEdge(mLastBottomInset, mLastRightInset);
            int navBarSize = getNavBarSize(mLastBottomInset, mLastRightInset);
            updateColorViewInt(mNavigationColorViewState, sysUiVisibility,
                    mWindow.mNavigationBarColor, navBarSize, navBarToRightEdge,
                    0 /* rightInset */, animate && !disallowAnimate, false /* force */);

            boolean statusBarNeedsRightInset = navBarToRightEdge
                    && mNavigationColorViewState.present;
            int statusBarRightInset = statusBarNeedsRightInset ? mLastRightInset : 0;
            updateColorViewInt(mStatusColorViewState, sysUiVisibility,
                    calculateStatusBarColor(), mLastTopInset,
                    false /* matchVertical */, statusBarRightInset, animate && !disallowAnimate,
                    mForceWindowDrawsStatusBarBackground);
        }

        // When we expand the window with FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, we still need
        // to ensure that the rest of the view hierarchy doesn't notice it, unless they've
        // explicitly asked for it.
        boolean consumingNavBar =
                (attrs.flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0
                        && (sysUiVisibility & SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0
                        && (sysUiVisibility & SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0
                || mLastShouldAlwaysConsumeNavBar;

        // If we didn't request fullscreen layout, but we still got it because of the
        // mForceWindowDrawsStatusBarBackground flag, also consume top inset.
        boolean consumingStatusBar = (sysUiVisibility & SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) == 0
                && (sysUiVisibility & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0
                && (attrs.flags & FLAG_LAYOUT_IN_SCREEN) == 0
                && (attrs.flags & FLAG_LAYOUT_INSET_DECOR) == 0
                && mForceWindowDrawsStatusBarBackground
                && mLastTopInset != 0;

        int consumedTop = consumingStatusBar ? mLastTopInset : 0;
        int consumedRight = consumingNavBar ? mLastRightInset : 0;
        int consumedBottom = consumingNavBar ? mLastBottomInset : 0;

        if (mContentRoot != null
                && mContentRoot.getLayoutParams() instanceof MarginLayoutParams) {
            MarginLayoutParams lp = (MarginLayoutParams) mContentRoot.getLayoutParams();
            if (lp.topMargin != consumedTop || lp.rightMargin != consumedRight
                    || lp.bottomMargin != consumedBottom) {
                lp.topMargin = consumedTop;
                lp.rightMargin = consumedRight;
                lp.bottomMargin = consumedBottom;
                mContentRoot.setLayoutParams(lp);

                if (insets == null) {
                    // The insets have changed, but we're not currently in the process
                    // of dispatching them.
                    requestApplyInsets();
                }
            }
            if (insets != null) {
                insets = insets.replaceSystemWindowInsets(
                        insets.getSystemWindowInsetLeft(),
                        insets.getSystemWindowInsetTop() - consumedTop,
                        insets.getSystemWindowInsetRight() - consumedRight,
                        insets.getSystemWindowInsetBottom() - consumedBottom);
            }
        }

        if (insets != null) {
            insets = insets.consumeStableInsets();
        }
        return insets;
    }
    
    
        /* package */ WindowInsets getWindowInsets(boolean forceConstruct) {
        if (mLastWindowInsets == null || forceConstruct) {
            mDispatchContentInsets.set(mAttachInfo.mContentInsets);
            mDispatchStableInsets.set(mAttachInfo.mStableInsets);
            Rect contentInsets = mDispatchContentInsets;
            Rect stableInsets = mDispatchStableInsets;
            // For dispatch we preserve old logic, but for direct requests from Views we allow to
            // immediately use pending insets.
            if (!forceConstruct
                    && (!mPendingContentInsets.equals(contentInsets) ||
                        !mPendingStableInsets.equals(stableInsets))) {
                contentInsets = mPendingContentInsets;
                stableInsets = mPendingStableInsets;
            }
            Rect outsets = mAttachInfo.mOutsets;
            if (outsets.left > 0 || outsets.top > 0 || outsets.right > 0 || outsets.bottom > 0) {
                contentInsets = new Rect(contentInsets.left + outsets.left,
                        contentInsets.top + outsets.top, contentInsets.right + outsets.right,
                        contentInsets.bottom + outsets.bottom);
            }
            mLastWindowInsets = new WindowInsets(contentInsets,
                    null /* windowDecorInsets */, stableInsets,
                    mContext.getResources().getConfiguration().isScreenRound(),
                    mAttachInfo.mAlwaysConsumeNavBar);
        }
        return mLastWindowInsets;
    }

// 这里是为什么呢dispatchApplyInsets

    void dispatchApplyInsets(View host) {
        host.dispatchApplyWindowInsets(getWindowInsets(true /* forceConstruct */));
    }
    
# Android4.4的半透明与fitSystemwindow 

设置了tranluctent，会将布局延伸到状态栏：fitSystemwindow会决定，将这部分padding算到谁头上 

# 理解5.0之后的版本，系统根布局与自己的布局的关系

fitsysystemwindow什么时候有效 


    public WindowInsets onApplyWindowInsets(WindowInsets insets) {
        if ((mPrivateFlags3 & PFLAG3_FITTING_SYSTEM_WINDOWS) == 0) {
            // We weren't called from within a direct call to fitSystemWindows,
            // call into it as a fallback in case we're in a class that overrides it
            // and has logic to perform.
            if (fitSystemWindows(insets.getSystemWindowInsets())) {
                return insets.consumeSystemWindowInsets();
            }
        } else {
            // We were called from within a direct call to fitSystemWindows.
            if (fitSystemWindowsInt(insets.getSystemWindowInsets())) {
                return insets.consumeSystemWindowInsets();
            }
        }
        return insets;
    }
    
    private boolean fitSystemWindowsInt(Rect insets) {
        if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
            mUserPaddingStart = UNDEFINED_PADDING;
            mUserPaddingEnd = UNDEFINED_PADDING;
            Rect localInsets = sThreadLocal.get();
            if (localInsets == null) {
                localInsets = new Rect();
                sThreadLocal.set(localInsets);
            }
            boolean res = computeFitSystemWindows(insets, localInsets);
            mUserPaddingLeftInitial = localInsets.left;
            mUserPaddingRightInitial = localInsets.right;
            internalSetPadding(localInsets.left, localInsets.top,
                    localInsets.right, localInsets.bottom);
            return res;
        }
        return false;
    }



    protected boolean computeFitSystemWindows(Rect inoutInsets, Rect outLocalInsets) {
        
        // 这里已经是满足 FITS_SYSTEM_WINDOWS 标志位
		// OPTIONAL_FITS_SYSTEM_WINDOWS 代表着是系统View 
		// SYSTEM_UI_LAYOUT_FLAGS 代表着全屏  
		// SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION| SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
     	//  如果是普通View可以直接消费，如果是系统View，要看看是不是设置了全屏      

        if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0
                || mAttachInfo == null
                || ((mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0
                        && !mAttachInfo.mOverscanRequested)) {
            outLocalInsets.set(inoutInsets);
            inoutInsets.set(0, 0, 0, 0);
            return true;
        } else {
            // The application wants to take care of fitting system window for
            // the content...  however we still need to take care of any overscan here.
            final Rect overscan = mAttachInfo.mOverscanInsets;
            outLocalInsets.set(overscan);
            inoutInsets.left -= overscan.left;
            inoutInsets.top -= overscan.top;
            inoutInsets.right -= overscan.right;
            inoutInsets.bottom -= overscan.bottom;
            return false;
        }
    }
    
OPTIONAL_FITS_SYSTEM_WINDOWS是通过 makeOptionalFitsSystemWindows设置的，只有PhoneWindow中的  mDecor.makeOptionalFitsSystemWindows() 用到了
   
        public void makeOptionalFitsSystemWindows() {
        setFlags(OPTIONAL_FITS_SYSTEM_WINDOWS, OPTIONAL_FITS_SYSTEM_WINDOWS);
    }


	 private void installDecor() {
	        mForceDecorInstall = false;
	        if (mDecor == null) {
	            mDecor = generateDecor(-1);
	            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
	            mDecor.setIsRootNamespace(true);
	            if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {
	                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
	            }
	        } else {
	            // 设置Window
	            mDecor.setWindow(this);
	        }
	        if (mContentParent == null) {
	            mContentParent = generateLayout(mDecor);
	
	            // Set up decor part of UI to ignore fitsSystemWindows if appropriate.
	
	            // 如果需要就
	            
	            mDecor.makeOptionalFitsSystemWindows();
            
            
注意installDecor的时候，里面还未涉及添加用到的view，所以mDecor.makeOptionalFitsSystemWindows标记的都是系统自己的View ，不信往下看

	
	 @Override
	    public void setContentView(View view, ViewGroup.LayoutParams params) {
	        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
	        // decor, when theme attributes and the like are crystalized. Do not check the feature
	        // before this happens.
	        if (mContentParent == null) {
	            installDecor();
	        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
	            mContentParent.removeAllViews();
	        }
	
	        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
	            view.setLayoutParams(params);
	            final Scene newScene = new Scene(mContentParent, view);
	            transitionTo(newScene);
	        } else {
	            mContentParent.addView(view, params);
	        }
	        mContentParent.requestApplyInsets();
	        final Callback cb = getCallback();
	        if (cb != null && !isDestroyed()) {
	            cb.onContentChanged();
	        }
	        mContentParentExplicitlySet = true;
	    }


因此对于系统的View，其实虽然跟布局设置了fitSystemWindow为true，但是如果你用来全屏参数，fitSystemWindow就会无效，

	 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
	 | SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN


同时设置SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION与SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN已经解决，系统不会处理，全靠底层应用的View进行兼容处理，

但是两者分开设置的时候，怎么处理？单独设置一个不是说fitSystemWindow也无效交给外面吗？为什么呢？




# Theme中设置fitsysytemwindow为什么会表现不一致

# 底部与顶部附加的两个View是怎么回事，有时候有，有时候没有

# 底部fitsystemwindow难道用的margin

# Theme主题中的fitsystemwindow有强制的意味

#  注意是隐藏还是悬浮在上面 

* View.SYSTEM_UI_FLAG_LOW_PROFILE Level 14  低功耗模式, 会隐藏状态栏图标, 在4.0上可以实现全屏
* View.SYSTEM_UI_FLAG_LAYOUT_STABLE Level 16  保持整个View稳定, 常跟bar 悬浮, 隐藏共用, 使View不会因为SystemUI的变化而做layout 
* View.SYSTEM_UI_FLAG_FULLSCREEN Level 16  状态栏隐藏 
* View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN Level 16  状态栏上浮于Activity 
* View.SYSTEM_UI_FLAG_HIDE_NAVIGATION Level 14  隐藏导航栏,  
* View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION Level 16  导航栏上浮于Activity 
* View.SYSTEM_UI_FLAG_IMMERSIVE Level 19  Kitkat新加入的Flag, 沉浸模式, 可以隐藏掉status跟navigation bar, 并且在第一次会弹泡提醒, 它会覆盖掉之前两个隐藏bar的标记, 并且在bar出现的位置滑动可以呼出bar 
* View.SYSTEM_UI_FLAG_IMMERSIVE_STIKY Level 19  与上面唯一的区别是, 呼出隐藏的bar后会自动再隐藏掉


#  剩余问题：

* 为什么想要的只让底部或者顶部全屏表现如实预期？
* 开始的WindowInsets怎么出来的？
    
#  更改导航栏颜色导致重绘
 
 
        @Override
    public void setNavigationBarColor(int color) {
        mNavigationBarColor = color;
        mForcedNavigationBarColor = true;
        if (mDecor != null) {
            mDecor.updateColorViews(null, false /* animate */);
            mDecor.updateNavigationGuardColor();
        }
    }
    
#   mOverscanInsets  系统级别的消费，怎么消费

# 顶部没办法用DecorView控制，但是底部可以，底部多变，不同设备也不同

* 顶部全靠Content的padding
* 底部靠DecorView的padding+content的paddding

![](http://upload-images.jianshu.io/upload_images/2179030-7151d4a653c9b5b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


 
 
#  底部与顶部的异同
 
     private final ColorViewState mStatusColorViewState = new ColorViewState(
            SYSTEM_UI_FLAG_FULLSCREEN, FLAG_TRANSLUCENT_STATUS,
            Gravity.TOP, Gravity.LEFT,
            Window.STATUS_BAR_BACKGROUND_TRANSITION_NAME,
            com.android.internal.R.id.statusBarBackground,
            FLAG_FULLSCREEN);
            
    private final ColorViewState mNavigationColorViewState = new ColorViewState(
            SYSTEM_UI_FLAG_HIDE_NAVIGATION, FLAG_TRANSLUCENT_NAVIGATION,
            Gravity.BOTTOM, Gravity.RIGHT,
            Window.NAVIGATION_BAR_BACKGROUND_TRANSITION_NAME,
            com.android.internal.R.id.navigationBarBackground,
            0 /* hideWindowFlag */);

#   6.0之前的代码，在DecorView中只是消费右边跟下边  ，没有上面的所以DecorView不会处理跟消费上面的，知乎交给Content容器，但是对于底部确做了处理 ，只要不设置SYSTEM_UI_FLAG_HIDE_NAVIGATION,DecorView就会消费掉底部的Padding，至于会不会绘制底层的覆盖View，一般显示的时候，一定消费了Inset，但是消费了不一定显示

           private WindowInsets updateColorViews(WindowInsets insets, boolean animate) {
            WindowManager.LayoutParams attrs = getAttributes();
            int sysUiVisibility = attrs.systemUiVisibility | getWindowSystemUiVisibility();

            if (!mIsFloating && ActivityManager.isHighEndGfx()) {
                boolean disallowAnimate = !isLaidOut();
                disallowAnimate |= ((mLastWindowFlags ^ attrs.flags)
                        & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;
                mLastWindowFlags = attrs.flags;

                if (insets != null) {
                    mLastTopInset = Math.min(insets.getStableInsetTop(),
                            insets.getSystemWindowInsetTop());
                    mLastBottomInset = Math.min(insets.getStableInsetBottom(),
                            insets.getSystemWindowInsetBottom());
                    mLastRightInset = Math.min(insets.getStableInsetRight(),
                            insets.getSystemWindowInsetRight());

                    // Don't animate if the presence of stable insets has changed, because that
                    // indicates that the window was either just added and received them for the
                    // first time, or the window size or position has changed.
                    boolean hasTopStableInset = insets.getStableInsetTop() != 0;
                    disallowAnimate |= (hasTopStableInset != mLastHasTopStableInset);
                    mLastHasTopStableInset = hasTopStableInset;

                    boolean hasBottomStableInset = insets.getStableInsetBottom() != 0;
                    disallowAnimate |= (hasBottomStableInset != mLastHasBottomStableInset);
                    mLastHasBottomStableInset = hasBottomStableInset;

                    boolean hasRightStableInset = insets.getStableInsetRight() != 0;
                    disallowAnimate |= (hasRightStableInset != mLastHasRightStableInset);
                    mLastHasRightStableInset = hasRightStableInset;
                }

                boolean navBarToRightEdge = mLastBottomInset == 0 && mLastRightInset > 0;
                int navBarSize = navBarToRightEdge ? mLastRightInset : mLastBottomInset;
                updateColorViewInt(mNavigationColorViewState, sysUiVisibility, mNavigationBarColor,
                        navBarSize, navBarToRightEdge, 0 /* rightInset */,
                        animate && !disallowAnimate);

                boolean statusBarNeedsRightInset = navBarToRightEdge
                        && mNavigationColorViewState.present;
                int statusBarRightInset = statusBarNeedsRightInset ? mLastRightInset : 0;
                updateColorViewInt(mStatusColorViewState, sysUiVisibility, mStatusBarColor,
                        mLastTopInset, false /* matchVertical */, statusBarRightInset,
                        animate && !disallowAnimate);
            }

            // When we expand the window with FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, we still need
            // to ensure that the rest of the view hierarchy doesn't notice it, unless they've
            // explicitly asked for it.

            boolean consumingNavBar =
                    (attrs.flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0
                            && (sysUiVisibility & SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0
                            && (sysUiVisibility & SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;

            int consumedRight = consumingNavBar ? mLastRightInset : 0;
            int consumedBottom = consumingNavBar ? mLastBottomInset : 0;

            if (mContentRoot != null
                    && mContentRoot.getLayoutParams() instanceof MarginLayoutParams) {
                MarginLayoutParams lp = (MarginLayoutParams) mContentRoot.getLayoutParams();
                if (lp.rightMargin != consumedRight || lp.bottomMargin != consumedBottom) {
                    lp.rightMargin = consumedRight;
                    lp.bottomMargin = consumedBottom;
                    mContentRoot.setLayoutParams(lp);

                    if (insets == null) {
                        // The insets have changed, but we're not currently in the process
                        // of dispatching them.
                        requestApplyInsets();
                    }
                }
                if (insets != null) {
                    insets = insets.replaceSystemWindowInsets(
                            insets.getSystemWindowInsetLeft(),
                            insets.getSystemWindowInsetTop(),
                            insets.getSystemWindowInsetRight() - consumedRight,
                            insets.getSystemWindowInsetBottom() - consumedBottom);
                }
            }

            if (insets != null) {
                insets = insets.consumeStableInsets();
            }
            return insets;
        }
        


不过最新的7.0有不同 DecorView也可以消费WindowInset，多了系统级的控制选项，开发过程无用，是ROM定制的。 mForceWindowDrawsStatusBarBackground 全局开关。
  
     // If we didn't request fullscreen layout, but we still got it because of the
        // mForceWindowDrawsStatusBarBackground flag, also consume top inset.


  
          boolean consumingNavBar =
                (attrs.flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0
                        && (sysUiVisibility & SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0
                        && (sysUiVisibility & SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0
                || mLastShouldAlwaysConsumeNavBar;

        // If we didn't request fullscreen layout, but we still got it because of the
        // mForceWindowDrawsStatusBarBackground flag, also consume top inset.
        
        boolean consumingStatusBar = 
        (sysUiVisibility & SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) == 0
                && (sysUiVisibility & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0
                && (attrs.flags & FLAG_LAYOUT_IN_SCREEN) == 0
                && (attrs.flags & FLAG_LAYOUT_INSET_DECOR) == 0
                && mForceWindowDrawsStatusBarBackground
                && mLastTopInset != 0;
                
 是否显示View的时机
 
      state.present = (sysUiVis & state.systemUiHideFlag) == 0
                && (mWindow.getAttributes().flags & state.hideWindowFlag) == 0
                && ((mWindow.getAttributes().flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0
                        || force);
        boolean show = state.present
                && (color & Color.BLACK) != 0
                && ((mWindow.getAttributes().flags & state.translucentFlag) == 0  || force);
        boolean showView = show && !isResizing() && size > 0;
                     
**color & Color.BLACK**  ，这就是透明，为什么不绘制的原理 哈哈哈哈哈哈 

# 所以状态栏夜色的设置，同沉浸式是两个概念，沉浸了，全屏了，仍然可以设置颜色分清楚 

         
# 参考文档

[Android沉浸式UI实现及原理](http://www.jianshu.com/p/f3683e27fd94)    
[WindowInsets和StatusBar](http://www.jianshu.com/p/f3fd5da4a902)       
[ Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析](http://blog.csdn.net/Luoshengyang/article/details/8479101)       
 [View绘制流程及源码解析(一)——performTraversals()源码分析](http://www.jianshu.com/p/a65861e946cb) 
[android:fitSystemWindows详解](https://my.oschina.net/KobeGong/blog/469059)     
[Using Immersive Full-Screen Mode](https://developer.android.com/training/system-ui/immersive.html)      