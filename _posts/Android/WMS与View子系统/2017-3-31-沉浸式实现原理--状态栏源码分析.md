---
layout: post
title: 沉浸式实现原理--状态栏源码分析  
category: Android

---
 
如果了解WMS的知识，就会知道，其实Surface的展示可以状体栏窗口+导航栏窗口+内容显示区域View窗口，Activity其实也只是View的容器，内容显示区域View其实是在导航及状态栏下面的，默认导航栏的优先级很高，浮在上面，Activity的内容都在下面，如果是全屏的并不是跟状态栏拼接，而是被覆盖，只是有背景，才导致了看不到，但是可以通过代码，设置导航栏及状态栏颜色，让底部可见，
 
 

    <style name="AppTheme.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="android:windowDrawsSystemBarBackgrounds">true</item>
        <item name="android:windowTranslucentStatus">true</item>
        <item name="android:statusBarColor">@color/red</item>
        <item name="android:navigationBarColor">@color/red</item>
    </style>
    
 不能要半透明，   android:windowTranslucentStatus，才能设置顶部statusbar的颜色，
 
 android:fitsSystemWindows="false"  android:fitsSystemWindows="true"在哪层消费呢，就在哪层起作用，Layout内部的作用是顶部padding，但是底部是margin
 
 
#  windowTranslucentStatus statusBarColor不能同时生效

 21版本以上的透明系统栏需要使用android:statusBarColor = "@android:color/transparent"来实现；这里android:windowTranslucentStatus肯定是为false的，因为这两个属性是不能同时生效的。但是由于android:windowTranslucentStatus属性的禁用，状态栏将不再会是浮在我们的window上。没关系，我们可以通过下面的方法达到一样的效果：

getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
其实设置android:windowTranslucentStatus属性时，正是系统帮我们设置了上面的Flag；上面我们在DecorView上调用这个方法，但其实可以在任何一个可见的View上进行调用，效果是一样的。

**：‘windowTranslucentStatus’和‘windowTranslucentNavigation’设置为true后就再设置‘statusBarColor’和‘navigationBarColor’就没有效果了。**

整个屏幕透明 ：配合方式

        //使得布局延伸到状态栏和导航栏区域
        window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
        //透明状态栏/导航栏
        window.setStatusBarColor(Color.TRANSPARENT);
        window.setNavigationBarColor(Color.TRANSPARENT);
        //这样的效果跟上述的主题设置效果类似
        
        纯代码实现
    
        <style name="AppTheme.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="android:windowDrawsSystemBarBackgrounds">true</item>
        <item name="android:statusBarColor">@color/transparent</item>
        <item name="android:windowTranslucentStatus">false</item>
        <item name="android:navigationBarColor">@color/transparent</item>
        <item name="android:windowTranslucentNavigation">false</item>
	    </style>
    
    
上面的可以让状态栏底部导航栏透明，如果     android:fitsSystemWindows="false" 内容充满真个屏幕  ，如果    android:fitsSystemWindows="true" 内容预留出顶部与底部，

 > 5.0的不用android:windowTranslucentStatus  android:windowTranslucentNavigation，这个是半透明的效果，不是全透明的，不好控制，颜色要自己控制的话，就在DecorView中消除这个影响。
 
实现Activity布局及全屏的时候，经常会有这样一个疑问：状态栏属于Activity的管理范畴吗？如果不归Activity管理，归谁管理呢？本篇就状态栏的实现及管理分析一下，并且针对沉浸式的实现来分析。对于平板与手机来说，两种实现是不同的，本文只针对手机。几个问题

*  Activity默认是全屏的吗？
*  状态栏与导航栏设置透明的为何还有颜色，颜色是谁的颜色
*  fitsysytemWindow的作用
*  全屏的实现，顶部与底部
*  fitsysytemwindow的消费以及实现原理（顶部分padding底部的margin）



顶部状态栏透明

底部导航栏透明


以上几个问题可能比较模糊

	StatusBarManagerService.java
	PhoneWindow.java
	PhoneStatusBar.java
	
	<string name="config_statusBarComponent" translatable="false">com.android.systemui.statusbar.phone.PhoneStatusBar</string>
	
	    private void addStatusBarWindow() {
        final int height = getStatusBarHeight();
        final WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                height,
                WindowManager.LayoutParams.TYPE_STATUS_BAR,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                    | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING
                    | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH,
                PixelFormat.TRANSLUCENT);

        lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;

        lp.gravity = getStatusBarGravity();
        lp.setTitle("StatusBar");
        lp.packageName = mContext.getPackageName();
        makeStatusBarView();
        mWindowManager.addView(mStatusBarWindow, lp);
    }

其实动源码很容易看出就是利用WMS的addView去添加窗口，当然绘制还是在本地，只是管理交给WMS，一定要记住所有View的绘制都是在本地，WMS只负责管理Window显示顺序及计算校准窗口大小

窗口的大小是可以改变的，比如状态栏，实现的时候有一个高度，但是**下拉显示的时候，会赋予全屏的高度**。

# 没有Activity就不能显示View吗，Service可以显示View并更新View吗？当然可以

图层的混合

    type   |  handle  | hint | flag | tr | blnd |   format    |     source crop (l,t,r,b)      |          frame         | name 
-----------+----------+------+------+----+------+-------------+--------------------------------+------------------------+------
       HWC | b66d63c0 | 0002 | 0000 | 00 | 0100 | RGBA_8888   |    0.0,    0.0, 1080.0, 1920.0 |    0,    0, 1080, 1920 | XXXXActivity
       HWC | b66d6af0 | 0002 | 0000 | 00 | 0105 | RGBA_8888   |    0.0,    0.0, 1080.0, 1615.0 |    0,    0, 1080, 1615 | PopupWindow:f8f8058
       HWC | b66d6550 | 0002 | 0000 | 00 | 0105 | RGBA_8888   |    0.0,    0.0, 1080.0,   72.0 |    0,    0, 1080,   72 | StatusBar
       HWC | b66d6690 | 0002 | 0000 | 00 | 0105 | RGBA_8888   |    0.0,    0.0, 1080.0,  144.0 |    0, 1776, 1080, 1920 | NavigationBar
 FB TARGET | b6a51c10 | 0000 | 0000 | 00 | 0105 | RGBA_8888   |    0.0,    0.0, 1080.0, 1920.0 |    0,    0, 1080, 1920 | HWC_FRAMEBUFFER_TARGET
 
 看一下上面的Surface的个数及参数，
 
*  第一个XXXXActivity，大小是屏幕大小
*  第二个popWindow大小是内容自身大小
*  第三个状态栏的大小
*  第四个是底部虚拟导航栏的大小
*  第五个是硬件对应大小

其实可以看出Activity是在状态栏与导航栏下面的，被覆盖了。 
 
# 状态栏的位置处于很高层次，在一般视图的上面

对于Activity的内容，并没有限制，只是显示的位置，是同主题及状态栏有个陪着，或者说有个便宜，如果没有ActionBar，会怎么样呢

# fitSystemWindow只会让内容下移一个状态栏的距离，padding，不是margin的作用

# 不同的根布局

没有ActionBar

	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
	    android:orientation="vertical"
	    android:fitsSystemWindows="true">
	    <!-- Popout bar for action modes -->
	    <ViewStub android:id="@+id/action_mode_bar_stub"
	              android:inflatedId="@+id/action_mode_bar"
	              android:layout="@layout/action_mode_bar"
	              android:layout_width="match_parent"
	              android:layout_height="wrap_content" />
	    <FrameLayout
	        android:layout_width="match_parent" 
	        android:layout_height="?android:attr/windowTitleSize"
	        style="?android:attr/windowTitleBackgroundStyle">
	        <TextView android:id="@android:id/title" 
	            style="?android:attr/windowTitleStyle"
	            android:background="@null"
	            android:fadingEdge="horizontal"
	            android:gravity="center_vertical"
	            android:layout_width="match_parent"
	            android:layout_height="match_parent" />
	    </FrameLayout>
	    <FrameLayout android:id="@android:id/content"
	        android:layout_width="match_parent" 
	        android:layout_height="0dip"
	        android:layout_weight="1"
	        android:foregroundGravity="fill_horizontal|top"
	        android:foreground="?android:attr/windowContentOverlay" />
	</LinearLayout>



含有ActionBar

	<com.android.internal.widget.ActionBarOverlayLayout
	    xmlns:android="http://schemas.android.com/apk/res/android"
	    android:id="@+id/action_bar_overlay_layout"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent"
	    android:splitMotionEvents="false">
	    <FrameLayout android:id="@android:id/content"
	        android:layout_width="match_parent"
	        android:layout_height="match_parent" />
	    <LinearLayout android:id="@+id/top_action_bar"
	                  android:layout_width="match_parent"
	                  android:layout_height="wrap_content">
	        <com.android.internal.widget.ActionBarContainer android:id="@+id/action_bar_container"
	            android:layout_width="match_parent"
	            android:layout_height="wrap_content"
	            android:layout_alignParentTop="true"
	            style="?android:attr/actionBarStyle"
	            android:gravity="top">
	            <com.android.internal.widget.ActionBarView
	                android:id="@+id/action_bar"
	                android:layout_width="match_parent"
	                android:layout_height="wrap_content"
	                style="?android:attr/actionBarStyle" />
	            <com.android.internal.widget.ActionBarContextView
	                android:id="@+id/action_context_bar"
	                android:layout_width="match_parent"
	                android:layout_height="wrap_content"
	                android:visibility="gone"
	                style="?android:attr/actionModeStyle" />
	        </com.android.internal.widget.ActionBarContainer>
	        <ImageView android:src="?android:attr/windowContentOverlay"
	                   android:scaleType="fitXY"
	                   android:layout_width="match_parent"
	                   android:layout_height="wrap_content" />
	    </LinearLayout>
	    <com.android.internal.widget.ActionBarContainer android:id="@+id/split_action_bar"
	                  android:layout_width="match_parent"
	                  android:layout_height="wrap_content"
	                  style="?android:attr/actionBarSplitStyle"
	                  android:visibility="gone"
	                  android:gravity="center"/>
	</com.android.internal.widget.ActionBarOverlayLayout>


看看如何定义根布局DecorView的子View

			 int layoutResource;
	        int features = getLocalFeatures();
	        // System.out.println("Features: 0x" + Integer.toHexString(features));
	        if ((features & ((1 << FEATURE_LEFT_ICON) | (1 << FEATURE_RIGHT_ICON))) != 0) {
	            if (mIsFloating) {
	                TypedValue res = new TypedValue();
	                getContext().getTheme().resolveAttribute(
	                        com.android.internal.R.attr.dialogTitleIconsDecorLayout, res, true);
	                layoutResource = res.resourceId;
	            } else {
	                layoutResource = com.android.internal.R.layout.screen_title_icons;
	            }
	            // XXX Remove this once action bar supports these features.
	            removeFeature(FEATURE_ACTION_BAR);
	            // System.out.println("Title Icons!");
	        } else if ((features & ((1 << FEATURE_PROGRESS) | (1 << FEATURE_INDETERMINATE_PROGRESS))) != 0
	                && (features & (1 << FEATURE_ACTION_BAR)) == 0) {
	            // Special case for a window with only a progress bar (and title).
	            // XXX Need to have a no-title version of embedded windows.
	            layoutResource = com.android.internal.R.layout.screen_progress;
	            // System.out.println("Progress!");
	        } else if ((features & (1 << FEATURE_CUSTOM_TITLE)) != 0) {
	            // Special case for a window with a custom title.
	            // If the window is floating, we need a dialog layout
	            if (mIsFloating) {
	                TypedValue res = new TypedValue();
	                getContext().getTheme().resolveAttribute(
	                        com.android.internal.R.attr.dialogCustomTitleDecorLayout, res, true);
	                layoutResource = res.resourceId;
	            } else {
	                layoutResource = com.android.internal.R.layout.screen_custom_title;
	            }
	            // XXX Remove this once action bar supports these features.
	            removeFeature(FEATURE_ACTION_BAR);
	        } else if ((features & (1 << FEATURE_NO_TITLE)) == 0) {
	            // If no other features and not embedded, only need a title.
	            // If the window is floating, we need a dialog layout
	            if (mIsFloating) {
	                TypedValue res = new TypedValue();
	                getContext().getTheme().resolveAttribute(
	                        com.android.internal.R.attr.dialogTitleDecorLayout, res, true);
	                layoutResource = res.resourceId;
	            } else if ((features & (1 << FEATURE_ACTION_BAR)) != 0) {
	                layoutResource = com.android.internal.R.layout.screen_action_bar;
	            } else {
	                layoutResource = com.android.internal.R.layout.screen_title;
	            }
	            // System.out.println("Title!");
	        } else if ((features & (1 << FEATURE_ACTION_MODE_OVERLAY)) != 0) {
	            layoutResource = com.android.internal.R.layout.screen_simple_overlay_action_mode;
	        } else {
	            // Embedded, so no decoration is needed.
	            layoutResource = com.android.internal.R.layout.screen_simple;
	            // System.out.println("Simple!");
	        }
        mDecor.startChanging();
        View in = mLayoutInflater.inflate(layoutResource, null);
        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));


# 推荐不使用ActionBar，全部自定义

# fitSystemWindow的入口ViewRootImpl

 private void performTraversals() {
          ...
	 host.fitSystemWindows(mFitSystemWindowsInsets);


# DecorView默认是充满全屏的

# 两个辅助View背景，这里只是背景，不涉及icon的绘制，floating=false都会有

        private final ColorViewState mStatusColorViewState = new ColorViewState(
                SYSTEM_UI_FLAG_FULLSCREEN, FLAG_TRANSLUCENT_STATUS,
                Gravity.TOP,
                Gravity.LEFT,
                STATUS_BAR_BACKGROUND_TRANSITION_NAME,
                com.android.internal.R.id.statusBarBackground,
                FLAG_FULLSCREEN);
        private final ColorViewState mNavigationColorViewState = new ColorViewState(
                SYSTEM_UI_FLAG_HIDE_NAVIGATION, FLAG_TRANSLUCENT_NAVIGATION,
                Gravity.BOTTOM,
                Gravity.RIGHT,
                NAVIGATION_BAR_BACKGROUND_TRANSITION_NAME,
                com.android.internal.R.id.navigationBarBackground,
                0 /* hideWindowFlag */);
                



    @Override
    public WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {
        insets = super.dispatchApplyWindowInsets(insets);
        if (!insets.isConsumed()) {
            final int count = getChildCount();
            for (int i = 0; i < count; i++) {
                insets = getChildAt(i).dispatchApplyWindowInsets(insets);
                if (insets.isConsumed()) {
                    break;
                }
            }
        }
        return insets;
    }
    
    public WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {
        try {
            mPrivateFlags3 |= PFLAG3_APPLYING_INSETS;
            if (mListenerInfo != null && mListenerInfo.mOnApplyWindowInsetsListener != null) {
                return mListenerInfo.mOnApplyWindowInsetsListener.onApplyWindowInsets(this, insets);
            } else {
                return onApplyWindowInsets(insets);
            }
        } finally {
            mPrivateFlags3 &= ~PFLAG3_APPLYING_INSETS;
        }
    }
    
    phonewindow

      private WindowInsets updateColorViews(WindowInsets insets, boolean animate) {
            WindowManager.LayoutParams attrs = getAttributes();
            int sysUiVisibility = attrs.systemUiVisibility | getWindowSystemUiVisibility();

            if (!mIsFloating && ActivityManager.isHighEndGfx()) {
                boolean disallowAnimate = !isLaidOut();
                disallowAnimate |= ((mLastWindowFlags ^ attrs.flags)
                        & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;
                mLastWindowFlags = attrs.flags;

                if (insets != null) {
                    mLastTopInset = Math.min(insets.getStableInsetTop(),
                            insets.getSystemWindowInsetTop());
                    mLastBottomInset = Math.min(insets.getStableInsetBottom(),
                            insets.getSystemWindowInsetBottom());
                    mLastRightInset = Math.min(insets.getStableInsetRight(),
                            insets.getSystemWindowInsetRight());
 
                    boolean hasTopStableInset = insets.getStableInsetTop() != 0;
                    disallowAnimate |= (hasTopStableInset != mLastHasTopStableInset);
                    mLastHasTopStableInset = hasTopStableInset;

                    boolean hasBottomStableInset = insets.getStableInsetBottom() != 0;
                    disallowAnimate |= (hasBottomStableInset != mLastHasBottomStableInset);
                    mLastHasBottomStableInset = hasBottomStableInset;

                    boolean hasRightStableInset = insets.getStableInsetRight() != 0;
                    disallowAnimate |= (hasRightStableInset != mLastHasRightStableInset);
                    mLastHasRightStableInset = hasRightStableInset;
                }

                boolean navBarToRightEdge = mLastBottomInset == 0 && mLastRightInset > 0;
                int navBarSize = navBarToRightEdge ? mLastRightInset : mLastBottomInset;
                updateColorViewInt(mNavigationColorViewState, sysUiVisibility, mNavigationBarColor,
                        navBarSize, navBarToRightEdge, 0 /* rightInset */,
                        animate && !disallowAnimate);

                boolean statusBarNeedsRightInset = navBarToRightEdge
                        && mNavigationColorViewState.present;
                int statusBarRightInset = statusBarNeedsRightInset ? mLastRightInset : 0;
                updateColorViewInt(mStatusColorViewState, sysUiVisibility, mStatusBarColor,
                        mLastTopInset, false /* matchVertical */, statusBarRightInset,
                        animate && !disallowAnimate);
            }
		 boolean consumingNavBar =
		                    (attrs.flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0
		                            && (sysUiVisibility & SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0
		                            && (sysUiVisibility & SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;

            int consumedRight = consumingNavBar ? mLastRightInset : 0;
            int consumedBottom = consumingNavBar ? mLastBottomInset : 0;
		<!--这里很关键，可以看到，根布局会根据消耗的状况，来评估到底底部，右边部分margin多少，并设置进去-->
            if (mContentRoot != null
                    && mContentRoot.getLayoutParams() instanceof MarginLayoutParams) {
                MarginLayoutParams lp = (MarginLayoutParams) mContentRoot.getLayoutParams();
                if (lp.rightMargin != consumedRight || lp.bottomMargin != consumedBottom) {
                    lp.rightMargin = consumedRight;
                    lp.bottomMargin = consumedBottom;
                    mContentRoot.setLayoutParams(lp);

                    if (insets == null) {
                        // The insets have changed, but we're not currently in the process
                        // of dispatching them.
                        requestApplyInsets();
                    }
                }
                if (insets != null) {
                    insets = insets.replaceSystemWindowInsets(
                            insets.getSystemWindowInsetLeft(),
                            insets.getSystemWindowInsetTop(),
                            insets.getSystemWindowInsetRight() - consumedRight,
                            insets.getSystemWindowInsetBottom() - consumedBottom);
                }
            }

            if (insets != null) {
                insets = insets.consumeStableInsets();
            }
            return insets;	
            }
            
    mContentRoot.setLayoutParams(lp);

可以看出其实布局文件中对于底部的边距是采用了Margin的方式，但是对于顶部，其实用的是padding


#     // 这里如何获取WindowInsets


    /* package */ WindowInsets getWindowInsets(boolean forceConstruct) {
        if (mLastWindowInsets == null || forceConstruct) {
            mDispatchContentInsets.set(mAttachInfo.mContentInsets);
            mDispatchStableInsets.set(mAttachInfo.mStableInsets);
            Rect contentInsets = mDispatchContentInsets;
            Rect stableInsets = mDispatchStableInsets;
            // For dispatch we preserve old logic, but for direct requests from Views we allow to
            // immediately use pending insets.
            if (!forceConstruct
                    && (!mPendingContentInsets.equals(contentInsets) ||
                        !mPendingStableInsets.equals(stableInsets))) {
                contentInsets = mPendingContentInsets;
                stableInsets = mPendingStableInsets;
            }
            Rect outsets = mAttachInfo.mOutsets;
            if (outsets.left > 0 || outsets.top > 0 || outsets.right > 0 || outsets.bottom > 0) {
                contentInsets = new Rect(contentInsets.left + outsets.left,
                        contentInsets.top + outsets.top, contentInsets.right + outsets.right,
                        contentInsets.bottom + outsets.bottom);
            }
            mLastWindowInsets = new WindowInsets(contentInsets,
                    null /* windowDecorInsets */, stableInsets,
                    mContext.getResources().getConfiguration().isScreenRound());
        }
        return mLastWindowInsets;
    }
    
    
#  Service内部同样可以更新View   



        这段代码用来获得Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight。
        注意，Activity窗口当前的宽度和高度是保存ViewRoot类的成员变量mWinFrame中的。ViewRoot类的另外两个成员变量mWidth和mHeight也是用来描述Activity窗口当前的宽度和高度的，但是它们的值是由应用程序进程上一次主动请求WindowManagerService服务计算得到的，并且会一直保持不变到应用程序进程下一次再请求WindowManagerService服务来重新计算为止。Activity窗口的当前宽度和高度有时候是被WindowManagerService服务主动请求应用程序进程修改的，修改后的值就会保存在ViewRoot类的成员变量mWinFrame中，它们可能会与ViewRoot类的成员变量mWidth和mHeight的值不同。

        如果Activity窗口是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true，那么它的当前宽度desiredWindowWidth和当前高度desiredWindowHeight就等于屏幕的宽度和高度，否则的话，它的当前宽度desiredWindowWidth和当前高度desiredWindowHeight就等于保存在ViewRoot类的成员变量mWinFrame中的宽度和高度值。

        如果Activity窗口不是第一次被请求执行测量、布局和绘制操作，并且Activity窗口主动上一次请求WindowManagerService服务计算得到的宽度mWidth和高度mHeight不等于Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight，那么就说明Activity窗口的大小发生了变化，这时候变量windowResizesToFitContent的值就会被标记为true，以便接下来可以对Activity窗口的大小变化进行处理。

# 状态栏与跟底部导航栏显示与隐藏

fitSystemWindow只是针对Decorview或者View来进行设置的  ，Decorview 的setSysytemUiVIsbility，21版本之上不用用trannlactent效果，会覆盖状态栏设置的效果。

# 参考文档

[Android沉浸式UI实现及原理](http://www.jianshu.com/p/f3683e27fd94)    
[WindowInsets和StatusBar](http://www.jianshu.com/p/f3fd5da4a902)       
[ Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析](http://blog.csdn.net/Luoshengyang/article/details/8479101)       
[深入理解android III]