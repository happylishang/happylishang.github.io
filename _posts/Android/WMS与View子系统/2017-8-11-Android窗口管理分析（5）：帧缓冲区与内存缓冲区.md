---
layout: post
title: Android窗口管理分析（5）：帧缓冲区与内存缓冲区的区别
category: Android
image: http://upload-images.jianshu.io/upload_images/1460468-103d49829291e1f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240

---

# 图层合成一直使用的硬件加速来处理 

硬件加速是一种技术，OpenGl技术，不仅仅是分配一块内存就行了。


# 绘图从内存到底来自何处，是匿名共享内存分配的还是帧缓冲区？？？

目前手机基本没有独立显存，都是在内存中分配，是需要硬件支持 （有可能混合渲染）

# LCD屏幕显示原理 

[闲聊Framebuffer](http://happyseeker.github.io/kernel/2016/05/24/about-framebuffer.html)

理解硬件加速的关键是要理解FrameBuffer框架，也就是所谓的帧缓冲区，帧缓冲区到底是什么呢？为什么向帧缓冲区写数据就能直接显示呢？

LCD控制器可以通过编程支持不同LCD屏的要求，例如行和列像素数，数据总线宽度，接口时序和刷新频率等。LCD控制器的主要作用，是将定位在系统存储器中的显示缓冲区中的LCD图像数据传送到外部LCD驱动器。

Framebuffer，也叫帧缓冲，其内容对应于屏幕上的界面显示，可以将其简单理解为屏幕上显示内容对应的缓存，修改Framebuffer中的内容，即表示修改屏幕上的内容，所以，直接操作Framebuffer可以直接从显示器上观察到效果，Framebuffer就是一段存储空间，其可以位于显存，也可以位于内存，只要是在GPU能够访问的空间范围内(GPU的物理地址空间)，任意分配一段内存(或显存)，都可以作为Framebuffer使用，只需要在分配后将该内存区域信息，设置到显卡相关的寄存器中即可。这个其实跟DMA区域的概念是类似的，访问内存的是GPU，是GPU，

使用GTT

当使用GTT时，将图像显示到显示器上的大致逻辑是这样的：

在内存中分配一块缓存区域(作为Framebuffer)
将需要绘制的图形对应的数据拷贝到这块内存区域，当然，这个拷贝操作显然是由CPU负责的，即消耗的是CPU，GPU完全不参与。
GPU将Framebuffer中内容显示到显示器上(swapBuffer)。这个操作是由GPU负责的，消耗的是GPU，CPU基本不参与。这个过程显然有个数据搬移(可以理解为拷贝)的操作，毕竟搬移之前，数据还在内存中，是不可能直接显示到显示器上的。这个过程可以理解为一次DMA操作。
这个过程可以看出，如果使用GTT在做Framebuffer，存在“两次”数据拷贝操作：

1.将数据拷贝到Framebuffer中 2.从Framebuffer到显示器的数据搬移

虽然有两次数据拷贝操作，但CPU只负责其中一次，另一次由GPU负责。


# Linux FrameBuffer框架  使用了加速的内存从哪分配来

使用的仍然我们的内存，我们需要把一些东西放到内存，让GPU处理？？？


写到fb即可，fb是动态的，不是写死，可以动态映射，LCD的控制器可以将这部分内存设置到自己的寄存器，这样等到使用的GPU总线可以直接访问这块内存


CPU（Central Processing Unit，中央处理器）是计算机设备核心器件，用于执行程序代码，软件开发者对此都很熟悉；GPU（Graphics Processing Unit，图形处理器）主要用于处理图形运算，通常所说“显卡”的核心部件就是GPU。

和CPU不同的是，GPU就是为实现大量数学运算设计的。从结构图中可以看到，GPU的控制器比较简单，但包含了大量ALU。GPU中的ALU使用了并行设计，且具有较多浮点运算单元。

硬件加速的主要原理，就是通过底层软件代码，将CPU不擅长的图形计算转换成GPU专用指令，由GPU完成。扩展：很多计算机中的GPU有自己独立的显存；没有独立显存则使用共享内存的形式，从内存中划分一块区域作为显存。显存可以保存GPU指令等信息。

![帧缓冲区与视频缓冲区如何显示原理.jpg](http://upload-images.jianshu.io/upload_images/1460468-f8a24dc172586bb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


# Android基于FB的实现

然后会调用createBufferQueue函数创建一个producer和consumer。然后又创建了一个FramebufferSurface对象。这里我们看到在新建FramebufferSurface对象时把consumer参数传入了代表是一个消费者。
而在DisplayDevice的构造函数中（下面会讲到），会创建一个Surface对象传递给底层的OpenGL ES使用，而这个Surface是一个生产者。在OpenGl ES中合成好了图像之后会将图像数据写到Surface对象中，这将触发consumer对象的onFrameAvailable函数被调用。
这就是Surface数据好了就通知消费者来拿数据做显示用，在onFrameAvailable函数汇总，通过nextBuffer获得图像数据，然后调用HWComposer对象mHwc的fbPost函数输出。

# 为什么硬件加速好用更多的内存

GPU使用的仍然我们的内存，我们需要把一些东西放到内存，让GPU处理？？？

写到fb即可，fb是动态的，不是写死，可以动态映射，LCD的控制器可以将这部分内存设置到自己的寄存器，这样等到使用的GPU总线可以直接访问这块内存

总线

![帧缓冲区与视频缓冲区如何显示原理.jpg](http://upload-images.jianshu.io/upload_images/1460468-f8a24dc172586bb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


[闲聊Framebuffer](http://happyseeker.github.io/kernel/2016/05/24/about-framebuffer.html)       
[Android SurfaceFlinger 学习之路(五)----VSync 工作原理](http://windrunnerlihuan.com/2017/05/25/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%94-VSync-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/)      
[美团技术团队 Android硬件加速原理与实现简介](https://tech.meituan.com/hardware-accelerate.html)

[视频讲解 Android应用程序UI硬件加速渲染技术 罗胜阳](http://www.infoq.com/cn/presentations/android-application-ui-hardware-accelerated-rendering-technology)     