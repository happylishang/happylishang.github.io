---
layout: post
title: "图片异步加载ImageAsyncCallback"
description: "Java"
category: android

---

### 二级缓存或者说三级缓存

* 二级缓存或者三级缓存是什么
* 为何用
* 怎嘛用


所谓三级缓存其实也可以说是二级缓存：内存-文件-网络 三层cache机制，其中内存缓存包括强引用缓存和软引用缓存（SoftReference），其实网络不算cache，这里姑且也把它划到缓存的层次结构中。当根据url向网络拉取图片的时候，先从内存中找，如果内存中没有，再从缓存文件中查找，如果缓存文件中也没有，再从网络上通过http请求拉取图片。在键值对（key-value）中，这个图片缓存的key是图片url的hash值，value就是bitmap。所以，按照这个逻辑，只要一个url被下载过，其图片就被缓存起来了。

#### LruCache对于一级缓存的处理

* 场景：ListView或者GrideView加载图片的时候
* 用法：避免使用弱引用，回收机制跟内存扩展时机混乱，也许扩展更好呢

> Note: In the past, a popular memory cache implementation was a SoftReference or WeakReference bitmap cache, however this is not recommended. Starting from Android 2.3 (API Level 9) the garbage collector is more aggressive with collecting soft/weak references which makes them fairly ineffective. In addition, prior to Android 3.0 (API Level 11), the backing data of a bitmap was stored in native memory which is not released in a predictable manner, potentially causing an application to briefly exceed its memory limits and crash.


> LruCache内存大小

* 看看APP其他部分对于内存的关心程度，比如如果是图片浏览器，当然可以尽可能大，单对于普通App要限定

* 看看每次屏幕显示多少图片，已经将要加载的缓存图片 上下几个屏幕

* 考虑屏幕分辨路，不同的屏幕分辨率不同，同时也要考虑图片的尺寸

* 针对不同的使用频率，使用场景，可以采用多个LruCache实例，比如对于本地浏览的的可以小一点，但是对于主页的LruCache可以大一点，而且对于本地的可以回收掉，但是对于主页没必要回收，如果只用一个就会有一个只增不减的问题。

* Can you balance quality against quantity? Sometimes it can be more useful to store a larger number of lower quality bitmaps, potentially loading a higher quality version in another background task.



LruCache效率对于列表比HashMap高，因为，遍历的时候，由于LrcCache采用是LinkHashMap，最后插入的在上面，可以最先遍历到。

经过测试LruCache的体验确实比软引用要好，并且没有内存抖动

SoftReference 或者 WeakReference做图片缓存的方法在Android 2.3版本以后已经不被推荐了。因为内存对SoftReference和WeakReference的回收更加频繁，从而也导致了我在上面说的反复从网络上拉取图片的操作。

在内存回收处理的时候，LruCache更加优雅 曲线更加顺滑，而且LruCache回收的比较晚，可扩展的内存大，避免每次都decode，就算占据内存，又能如何，不用白不用。内存多了又不耗电。
	
	[dalvik.vm.heapgrowthlimit]: [96m]
	[dalvik.vm.heapmaxfree]: [8m]
	[dalvik.vm.heapminfree]: [512k]
	[dalvik.vm.heapsize]: [256m]
	[dalvik.vm.heapstartsize]: [8m]
	[dalvik.vm.heaptargetutilization]: [0.75]
 
在android开发中，如果要使用大堆。需要在manifest中指定android:largeHeap为true。这样dvm heap最大可达dalvik.vm.heapsize。其中分配过程，可
    
所以有时候 256的时候才

#### DiskLruCache的使用

#### Android Retain Fragment  Handle Configuration Changes

* Create a Generic RetainFragment<T> that can be used to store any type of data.
* Create a Generic ContainFragment<T> that contains the RetainFragment<T>, and handles it's lifecycle events (other reasons will be discussed later).

[Android Retain Fragment详解 处理屏幕旋转](http://bcorso.github.io/android-retain-fragment/)

		public class RetainFragment<T> extends Fragment {
		    public T data;
		
		    @Override
		    public void onCreate(Bundle savedInstanceState) {
		        super.onCreate(savedInstanceState);
		
		        // Keeps this Fragment alive during configuration changes
		        setRetainInstance(true);
		    }
		    
		    // Find/Create in FragmentManager
		    public static <T> RetainFragment<T> findOrCreate(FragmentManager fm, String tag) {
		        RetainFragment<T> retainFragment = (RetainFragment<T>) fm.findFragmentByTag(tag);
		
		        if(retainFragment == null){
		            retainFragment = new RetainFragment<>();
		            fm.beginTransaction()
		                    .add(retainFragment, tag)
		                    .commitAllowingStateLoss();
		        }
		
		        return retainFragment;
		    }
		
		    // Remove from FragmentManager
		    public void remove(FragmentManager fm) {
		        if(!fm.isDestroyed()){
		            fm.beginTransaction()
		                    .remove(this)
		                    .commitAllowingStateLoss();
		            data = null;
		        }
		    }
		}

### GridView图片浏览事项



	<GridView android:id="@+id/grid"    
	android:layout_width="fill_parent"    
	android:layout_height="fill_parent"    
	android:verticalSpacing="35px" <!-- grid元素之间的竖直间隔 -->    
	android:horizontalSpacing="5px" <!--grid元素之间的水平间隔 -->    
	android:numColumns="auto_fit" <!--表示有多少列，如果设置为auto_fit，将根据columnWidth和Spacing来自动计算 -->    
	android:columnWidth="100px" <!-- 一般建议采用有像素密度无关的dip或者dp来表示-->    
	android:stretchMode="columnWidth" <!--如何填满空余的位置，模拟器采用WVGA800*480，每排4列，有4＊100＋5＊3＝415，还余65px的空间，如果是columnWidth，则这剩余的65将分摊给4列，每列增加16/17px。如果采用SpacingWidth，则分摊给3个间隔空隙 -->    
	android:gravity="center" />  
	
我们知道在oncreate中View.getWidth和View.getHeight无法获得一个view的高度和宽度，这是因为View组件布局要在onResume回调后完成。所以现在需要使用getViewTreeObserver().addOnGlobalLayoutListener()来获得宽度或者高度。这是获得一个view的宽度和高度的方法之一。



* 如何设置GridView的行高、每个Item的宽度



        private GridView.LayoutParams mImageViewLayoutParams;
        
              imageView.setLayoutParams(mImageViewLayoutParams);
              

        mGridView.getViewTreeObserver().addOnGlobalLayoutListener(
                new ViewTreeObserver.OnGlobalLayoutListener() {
                    @TargetApi(VERSION_CODES.JELLY_BEAN)
                    @Override
                    public void onGlobalLayout() {
                        if (mAdapter.getNumColumns() == 0) {
                            final int numColumns = (int) Math.floor(
                                    mGridView.getWidth() / (mImageThumbSize + mImageThumbSpacing));
                            if (numColumns > 0) {
                                final int columnWidth =
                                        (mGridView.getWidth() / numColumns) - mImageThumbSpacing;
                                mAdapter.setNumColumns(numColumns);
                                mAdapter.setItemHeight(columnWidth);
                                if (BuildConfig.DEBUG) {
                                    Log.d(TAG, "onCreateView - numColumns set to " + numColumns);
                                }
                                if (Utils.hasJellyBean()) {
                                    mGridView.getViewTreeObserver()
                                            .removeOnGlobalLayoutListener(this);
                                } else {
                                    mGridView.getViewTreeObserver()
                                            .removeGlobalOnLayoutListener(this);
                                }
                            }
                        }
                    }
                });
  
  
####   获取ActionBar高度

                mActionBarHeight = TypedValue.complexToDimensionPixelSize(
                        tv.data, context.getResources().getDisplayMetrics());
                                                    
#### 常见的问题 

* Tag设置冲突问题

 因为图片异步加载一般都有个Tag，用来标识当前ImageView对应哪个异步回调任务。但是，由于View不仅仅有加载需求，还可能处理单击事件等，也要保持Holder，如何处理，加一层处理？
 
####  参考文档

[Android Retain Fragment详解 处理屏幕旋转](http://bcorso.github.io/android-retain-fragment/)