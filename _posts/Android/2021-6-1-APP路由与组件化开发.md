前端开发经常遇到一个词：路由，在Android APP开发中，路由还经常和组件化开发强关联在一起，那么到底什么是路由，一个路由框架到底应该具备什么功能，实现原理是什么样的？路由是否是APP的强需求呢？与组件化到底什么关系，本文就简单分析下如上几个问题。

## 路由

路由这个词本身应该是互联网协议中的一个词，维基百科对此的解释如下：

	路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。路由发生在OSI网络参考模型中的第三层即网络层。

个人理解，在前端开发中，**路由**就是通过**一串字符串映射到对应业务的能力**。

## APP的路由框架应该具备什么能力

APP 的路由框首先能够搜集各组件的路由scheme，并生成路由表，然后，能够根据外部输入字符串在路由表中匹配到对应的页面或者服务，进行跳转或者调用，并提供会获取返回值等，示意如下

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f237ee5e0e4642c3a07732052f14a14e~tplv-k3u1fbpfcp-watermark.image)

所以一个基本路由框架要具备如下能力：

* 1. APP路由的扫描及注册逻辑
* 2. 路由跳转target页面能力
* 3. 路由调用target服务能力

APP中，在进行页面路由的时候，经常需要判断是否登录等一些额外鉴权逻辑所以，还需要提供如下拦截逻辑：

* 4  ：APP特有的路由拦截逻辑【比如：登陆、校验】

## 三方路由框架是否是APP强需求

答案：不是，但稍微大规模的APP都需要该能力。

Android系统本身提供页面跳转能力：如startActivity，对于工具类APP，或单机类APP，这种方式已经完全够用，完全不需要专门的路由框架，那为什么很多APP还是采用路由框架呢？这跟APP性质及路由框架的优点都有关。

## Android原生路由的缺点  ：功能单一，扩展灵活性差，不易协同

传统的路由基本上就限定在startActivity、或者startService来路由跳转或者启动服务。拿startActivity来说，传统的路由有什么缺点：startActivity有两种用法，一种是显示的，一种是隐式的，显示调用如下：

	<!--1 导入依赖-->
	import com.snail.activityforresultexample.test.SecondActivity;
	
	public class MainActivity extends AppCompatActivity {
	
	    void jumpSecondActivityUseClassName(){
	    <!--显示的引用Activity类-->
	        Intent intent =new Intent(MainActivity.this, SecondActivity.class);
	        startActivity(intent);
	    }
	    
显示调用的缺点很明显，那就是必须要强依赖目标Activity的类实现，有些场景，尤其是大型APP组件化开发时候，有些业务逻辑出于安全考虑，并不想被源码或aar依赖，这时显式依赖的方式就无法走通。再来看看隐式调用方法。

第一步：manifest中配置activity的intent-filter，至少要配置一个action

	<?xml version="1.0" encoding="utf-8"?>
	<manifest xmlns:android="http://schemas.android.com/apk/res/android"
	    package="com.snail.activityforresultexample">
	    <application
	       ...
	    <activity android:name=".test.SecondActivity">
	            <intent-filter>
	            <!--隐式调用必须配置android.intent.category.DEFAULT-->
	                   <category android:name="android.intent.category.DEFAULT"/>
	            <!--至少配置一个action才能通过隐式调用-->
	                <action android:name="com.snail.activityforresultexample.SecondActivity" />
	                <!--可选-->
	  <!--              <data android:mimeType="video/mpeg" android:scheme="http" ... />-->
	            </intent-filter>
	        </activity>
	    </application>
	</manifest>

第二步：调用

    void jumpSecondActivityUseFilter() {
        Intent intent = new Intent();
        intent.setAction("com.snail.activityforresultexample.SecondActivity");
        startActivity(intent);
    }

如果牵扯到数据参数的传递还有过滤写法上可能会更复杂一些，上述的缺点也很明显，

* 首先manifest中定义复杂，相对应的会导致暴露的协议变的复杂，不易维护扩展。
* 其次，不同Activity都要不同的action配置，每次增减修改Activity都会很麻烦，对比开发者非常不友好，增加了协作难度。
* 最后，Activity的export属性并不建议都设置成True，这是降低风险的一种方式，一般都是收归到一个Activity，DeeplinkActivitiy统一处理跳转，这种场景下，DeeplinkActivitiy就兼具路由功能，隐式调用的场景下，新Activitiy的增减势必每次都要调整路由表，这会导致开发效率降低，风险增加。

对于服务功能的路由，上述问题同样存在，同时，原生的路由框架不存在所谓的拦截逻辑，而三方路由框架就是为了解决上述问题而产生的。

## APP三方路由框架需具备的基础能力及扩展能力

三方路由想要有竞争力就需解决以上问题，目前市面上大部分的路由框架都能搞定上述能力，简单整理下现在三方路由的能力，可归纳如下：

*  基础路由跳转能力  ：页面跳转能力的支持
*  服务类组件的支持 ：如去某个服务组件获取一些配置等
*  scheme与业务映射逻辑 ：无需依赖具体实现，做到代码隔离
*  业务组件**[UI业务及服务]**自动扫描及注册逻辑：扩展性好，无需入侵原有代码逻辑
*  路由拦截逻辑：比如登陆，统一鉴权

可以看下一个典型的Arouter用法，第一步：对新增页面添加Router Scheme 声明，


		@Route(path = "/test/activity2")
		public class Test2Activity extends AppCompatActivity {
			 ...
		}

build阶段会根据注解搜集路由scheme，生成路由表，第二步使用

            ARouter.getInstance()
                    .build("/test/activity2")
                    .navigation(this);

可以看到在ARouter框架下，仅需要字符串Scheme，无需依赖任何Test2Activity就可实现路由跳转。





参考 [Android路由方案选型](http://www.ssevening.com/android%E5%BC%80%E5%8F%91/2017/06/11/Android%E8%B7%AF%E7%94%B1%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/)

在国外，一个App，只负责一个功能，比如：看电影、充话费、购物、旅游等，一个功能，就会做成一个App，但在国内，就是喜欢做一个大而全的全家桶，比如万能的淘宝、万能的微信、万能的支付宝、万能的大众点评，但模块一多，要解决的问题也就来了。问题如下：

模块多，代码多，方法数超过65534，要分成多个DEX，否则无法打出APK安装包。
模块间的相互调用和解耦，从A Activity 跳转到 B Activity，但又不能代码依赖，要怎么解决？
因为模块多，功能也多，测试 花在回归测试上的工作量就会上去，影响发版速度。
因为模块多，出问题也就多，各个模块紧急发布版本的可能性也多。
问题1 很简单的可以通过mutiDex解决，今天我们来聊一聊问题2 的解决，那就是 Android的模块间路由。

建立字符串和具体Activity的映射关系，模块跳转的时候，查找字符串映射的Activity路径，并启动Activity.


* 在一些复杂的业务场景下，灵活性比较强，很多功能都是动态配置的，比如下发一个活动页面，我们事先并不知道具体的目标页面，但如果事先做了约定，提前做好页面映射，便可以自由配置。

* 随着业务量的增长，客户端必然随之膨胀，开发人员的工作量越来越大，比如64K问题，比如协作开发问题。

* App一般都会走向组件化的道路，而组件化的前提就是解耦，那么我们首先要做的就是解耦页面之间的依赖关系。
 
* 简化代码。数行跳转代码精简成一行代码。
 



 

## APP路由框架如何实现

*  基于注解，使用方便，源码简洁
* 链式调用，api友好
* 多路径支持
* 结果回调，每次跳转都会回调跳转结果
* 编译期处理注解，不影响运行时性能
* 除了可以使用注解定义路由，还支持手动分配路由
* 自定义拦截器，可以对路由进行拦截，比如登录判断和埋点处理
* 自定义路由匹配规则，相比较其他路由框架，该项目并没有限制路由的写法，除了内置的几个匹配器，用户完全可以定义自己的规则
* 支持隐式Intent跳转
* 支持多模块使用，支持组件化开发
* 不仅支持注解Activity，还支持注解Fragment
* 支持Kotlin

* JAVA代码Class.forName的方式。
* Schema 映射Activity的方式。
* 自建 string 和 Activity 映射关系管理方式。【比如:ARouter】
	
	try {
	    Class c = Class.forName("www.ssevening.com.MainActivity");
	    intent = new Intent(activity, c);
	    intent.putExtra("key", "value");
	    // 添加类目
	    //intent.addCategory("")
	    // 设置相应的flag
	    // intent.setFlags()
	    activity.startActivity(intent);
	} catch (ClassNotFoundException e) {
	    e.printStackTrace();
	}

Android 组件化的架构大致如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbfba17750e84f32ba729fda8c69712d~tplv-k3u1fbpfcp-watermark.image)


> 组件化：更像一种**开发规范**，一种高内聚低耦合原则的落地实践

## 组件化开发到底在搞什么

组件化是一种开发集成模式，为开发带来了便利跟安全，最终落地是一个个独立的业务及功能组件，


 

## 组件间通信

**组件限定业务功能类组件**，组件间通信简单归为如下3种：

* 第一种，A组件路由到B组件，无需任何返回值【一般指Activity路由】
* 第二种，A组件路由到B，B需要提供返回值或者提供服务加回调【可以指Activity路由后的返回值，或者纯服务回调】
* 第三种，A组件路将结果以广播的形式通知其他组件【Activity跳转 或者 服务 ->Eventbus】


示意图如下：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80679b7e687545ec9a5da1134423ffe4~tplv-k3u1fbpfcp-watermark.image)

以上三种能力中，前两个要依赖Router框架的基础能力来实现，第三个需要借助Android的EventBus广播来实现。重点要强调的是2，有返回值【回调】，因为它牵扯到一个协议的问题。一个组件要暴露结果的方式一般是固定的， 抛出的结果如何被外部解析，这个就是一个协议规范的问题。在Android中，界面B的结果想要直传给上一个界面A，一般是通过onActivityResult来实现,调用界面A如果想要获取target B界面的返回值，只要在A Activity中实现 onActivityResult既可以，为了方便调用onActivityResult可以通过不可见Fragment封装成回调的方式来处理。

    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
    
    }

* requestCode 调用放A用来标识自己发起
* resultCode  B用来回传是否是成功or失败
* Intent data **暴露处理结果的核心，需重点关注其暴露方式**

目前Router框架有两种处理方式，
* 第一种 ：将需要返回值或者回调的逻辑抽象成服务，基础的服务接口沉淀到底层，具体业务负责实现，不过业务调用方需要依赖底层，这种方式的优势是接口干净清晰，调用者知道具体的应用场景跟规则，缺点是扩展新业务的时候要经常修改底层模块。Arouter就是采用这种。
* 第二种：统一封装回调，回调的协议完全依赖文档处理，回调返回数据统一JSON封装，各字段意义靠协议维护。这种的优点是不用频繁修改底层，缺点是调用方需要强依赖文档，即：一个业务组件如何暴露自己的返回值,示意图如下


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61988057cd12429491bfdb0f5e7a4e8a~tplv-k3u1fbpfcp-watermark.image)

当一个UI组件被完整输出的时候，它应该输出以上三方面的东西，其中第一个是必选项，后两个可以选，即：被调用组件可以没有返回数据及广播消息[EventBus] 
 
## 路由自动注册

每个抽离的业务组件都支持动态注册，依赖注解完成个模块功能的注册，



