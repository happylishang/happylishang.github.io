第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

知道彼此的收发能力正常？


B方第二次SYN没有返回ACK 会怎样？

* 对方收到  不发，直接发数据可以吗 ？可以
* 对方没收到  重发第一个SYN

B方等着没有收到第一个重复SYN就能确定成功  ？？


假如网络中有延时的SYN后面来了会怎么样 ？

这个时候，服务端会建立两个链接 ？？ 有办法解决吗？

又收到SYN之后，服务端接着发SYN+ACK，抛弃第一个链接吗 ？ 先收到数据会怎么样 ？




### 如果第一个SYN丢了 （长时间没收到ACK 重传）


### 如果第二个SYN+ACK丢了 （长时间没收到ACk 重传）

### 如果客户端发送的第三个ACK包丢了，那么客户端和服务端分别进行什么处理呢

相信了解 tcp 协议的人，三次握手的过程肯定很了解了。第三次的 ack 包丢失就是说在 client 端接收到 syn + ack 之后，向 server 发送的 ack 包 由于各种原因 server 没有收到。这时 client, server 分别会进行怎样的处理呢？

这个时候，客户单可以发送数据了，但是服务端还没建立，只是出于syn-recive状态。

SYN占用一个序列号，具有超时重传机制，ACK 不占用序列号，他只是用来确认发送到那个了，不需要占用 SYN占用了一个，具备重传的属性，所以失败了，肯定是重传当前一样是SYN
 

> Server 端

第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。

而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.

如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。

 

> Client 端

在linux c 中，client 一般是通过 connect() 函数来连接服务器的，而connect()是在 TCP的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK包，它的TCP连接状态就为 established （已连接），表示该连接已经建立。那么如果 第三次握手中的ACK包丢失的情况下，Client 向 server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。