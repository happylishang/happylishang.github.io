---
layout: blog_content
title: Java类加载机制
category: Java
tag: [Java]

---

## Java类动态加载机制

### 什么是动态加载-ClassLoader

    Java程序在启动的时候，不会一次性加载所有class文件，而是根据程序的需要，通过ClassLoader- 类加载机制来动态加载某个class文件到内存当中的，只有class文件被载入内存后，才能被其它class所引用，类加载实质是获取字节码，并把字节码生成JVM可以识别的Class对象。
    
### ClassLoader分类

一类归属于JVM范畴，用户无法直接调用；一类属于用户自定义的类加载器。

三种JVM加载器从下到上分别为sun.misc.Launcher$AppClassLoader、sun.misc.Launcher$ExtClassLoader(具体代码在底部)、BootstrapClassLoader。除了引导类加载器(BootstrapClassLoader)之外，所有的类加载器都有一个父类加载器。请注意，这里的父类加载器和类继承中的父类是不一样的，和父子继承没有任何关系。这里的父类加载器你可以理解成更高一层的类加载器，因为在JVM类加载中是采用的父类加载器委托的机制，即当使用一个类加载器加载某个类的时候，该类加载器不会自己直接去加载而是让比它等级更高的父加载器加载，但是也有特殊的场景(这个在下面细谈)。

  其加载过程就是，当调用一个类加载器请求一个类进行加载，那么该类加载器会首先把该请求提交到其父加载器，让后让父加载器进行加载。当父加载器寻找不到该类的时候(因为每个加载器加载路径被限制)，这时候才采用第一个被调用的类加载器进行加载。采用此做法的好处是避免重复加载一个类，导致安全问题。上面我们已经说明对于同一个类，不同类加载器进行加载，生成的class对象也会不相同，所以如果任何一个类加载器都进行加载而不是上交给父类，那么同一个类就可能在内存中存在多个对象。

  比如对于所有类的父类Object它理应是由JVM自己加载器进行加载，如果不实用委托父加载器加载机制，那么我们就同样可以使用自己编写的类加载器进行加载，那么这时候内存中就会存在两个Object对象。但是如果使用委托父加载器，就不会出现这情况。因为，当我们要加载Object类的时候，当前类加载器就会把该加载任务移交给父类，有可能一直到顶层父类。在父类中发现Object类已经加在成功了，那么下面就什么都不做。这样就保证了内存中只有一个Object对象，而不会出现重复加载的情况。

* BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，
* Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。
* App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。

    除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension ClassLoader和App ClassLoader）在内，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。
    
### 类的加载时机

  那什么时候JVM会加载一个类那，java规范规定，当出现如下情况的时候，则必须主动加载并初始化一个类。

  * 1：当使用new关键字，和读取一个类的静态属性的时候(静态变量与静态方法，但是静态final的除外)。这里对访问静态变量需要注意，加载是仅加载定义该静态变量的类。在C类中通过A的子类B访问A中静态变量的时候，B是不会被加载与初始化的，只会加载并初始化A。因为我们只访问了A中定义的静态变量，这一点需要注意。

  * 2：当使用反射获取一个类的时候；

  * 3：当初始化一个子类，必须首先加载并初始化其父类；

  * 4：当执行一个含有main方法的类的时候，必须首先加载含有那个main方法的类。

  * 除了上述四条之外则不能保证会加载并初始化一个类。
  
### 类加载过程

### Java中的绑定

绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定：

静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。

动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的

  