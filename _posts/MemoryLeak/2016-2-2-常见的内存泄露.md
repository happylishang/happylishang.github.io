---

layout: post
title: "常见的内存泄露"
description: "android"
category: android
tags: [android]

---

### .常见的内存泄露

> **目录**  
> **1**. [内存泄露概述](#anchor_digest)  
> **2**. [Webview导致的内存泄露](#anchor_webview)  
> **3**. [Hanlder导致的内存泄露](#anchor_handler)  
> **4**. [静态变量导致的内存泄露](#anchor_static_field)  
> **5**. [Dialog导致的内存泄露](#anchor_dialog)  
> **6**. [参考文档](#reference)  

<a name="anchor_digest"></a>

### .内存泄露概述

<a name="anchor_webview"></a>

### .Webview导致的内存泄露
Webview的使用，尤其当加载多个界面的时候，如果不合理的回收，很容易导致内存泄露问题.
使用方法

<a name="anchor_handler"></a>

### .Hanlder导致的内存泄露

如果一个内部类实例的生命周期比Activity更长，那么我们千万不要使用非静态的内部类。比较合理的解决方式是使用静态内部类，然后在该类里使用弱引用来指向所在的Activity。Handler便是此类的一个代表，使用不当很容易导致内存泄露，尤其是发送具有延时特性的消息时，当Android应用启动时，Android Framework会为主线程创建一个Looper对象。这个Looper对象包含一个简单的消息队列Message Queue，并且能够循环的处理队列中的消息。这些消息包括大多数应用程序Framework事件，例如Activity生命周期方法调用(onCreate)、View事件点击等，这些消息都会被添加到消息队列中并被逐个处理。并且，主线程的Looper对象会伴随该应用程序的整个生命周期。如果在主线程里，实例化一个Handler对象后，它就会自动与主线程Looper的消息队列关联起来，所有发送到消息队列的消息Message都会拥有一个对Handler的引用，但是，从Java角度来看，非静态内部类和匿名类都会隐性的的引用它们所属的外部类，而静态内部类却不会，因此，非静态内部类和匿名类有时候就会导致外部类无法被及时回收。

首先，请浏览下面这段handler代码：

		public class SampleActivity extends Activity {
		  private final Handler mLeakyHandler = new Handler() {
		    @Override
		    public void handleMessage(Message msg) {
		    }
		  }
		  
	 @Override
	  protected void onCreate(Bundle savedInstanceState) {
	    super.onCreate(savedInstanceState);
	    mLeakyHandler.postDelayed(new Runnable() {
	      @Override
	      public void run() { /* ... */ }
	    }, 1000 * 60 * 10);

	    finish();
	  }
	 }
    }
在使用handler时，这是一段很常见的代码。但是，它却会造成严重的内存泄漏问题。在实际编写中，开发工具往往会提示如下警告：

		 ⚠ In Android, Handler classes should be static or leaks might occur.
对于上面的代码，当activity结束finish时，在延时消息在得到处理前，消息会一直保存在主线程的消息队列里持续10分钟。而且，这条消息持有对handler的引用，而handler又持有对其外部类（在这里，即SampleActivity）的潜在引用。这条引用关系会一直保持直到消息得到处理，从而，这阻止了SampleActivity被垃圾回收器回收，造成应用程序的泄漏。


* 只要有未处理的消息，那么消息会引用handler（消息的处理会依赖Hanlder，因此肯定不会释放Handlder），非静态的handler又会引用外部类，即Activity，导致Activity无法被回收，造成泄漏；
			
	    public class Handler {
	    ...
		   		private boolean enqueueMessage(Message..) {
			    msg.target = this;
		 ...
		        
* Runnable类属于非静态匿名类，同样会引用外部类。

* 为了解决遇到的问题，我们要明确一点：静态内部类不会持有对外部类的引用。所以，我们可以把handler类放在单独的类文件中，或者使用静态内部类便可以避免泄漏。

* 另外，如果想要在handler内部去调用所在的外部类Activity，那么可以在handler内部使用弱引用的方式指向所在Activity，这样统一不会导致内存泄漏。

* 对于匿名类Runnable，同样可以将其设置为静态类。因为静态的匿名类不会持有对外部类的引用。

		public class SampleActivity extends Activity {
		
		  private static class MyHandler extends Handler {
		    private final WeakReference<SampleActivity> mActivity;
		
		    public MyHandler(SampleActivity activity) {
		      mActivity = new WeakReference<SampleActivity>(activity);
		    }
		
		    @Override
		    public void handleMessage(Message msg) {
		      SampleActivity activity = mActivity.get();
		      if (activity != null) {
		        // ...
		      }
		    }
		  }
		
		  private final MyHandler mHandler = new MyHandler(this);
		
		  /**
		   * Instances of anonymous classes do not hold an implicit
		   * reference to their outer class when they are "static".
		   */
		  private static final Runnable sRunnable = new Runnable() {
		      @Override
		      public void run() { /* ... */ }
		  };
		
		  @Override
		  protected void onCreate(Bundle savedInstanceState) {
		    super.onCreate(savedInstanceState);
		
		    // Post a message and delay its execution for 10 minutes.
		    mHandler.postDelayed(sRunnable, 1000 * 60 * 10);
		
		    // Go back to the previous Activity.
		    finish();
		  }
		}



<a name="anchor_static_field"></a>

### .静态变量导致的内存泄露

对于不合理的使用单利模式，或者静态变量，如果该变量包含某个占用内存大的类的引用，在该静态变量回收之前，被引用的类是不会被回收的，这就可能导致内存泄露，因为可能在某个界面，已经不需要那个类了，但是它仍然占用着内存。

例子：

	class B{
	
		public B(Context context){}
	}
	
	class A{
	
		private static B b;
	}
	
  一旦创建A，并在其中实例化B，即使A被回收了，如未显性的将B置空，B将不会被回收，由于B保持着context的引用，导致context也无法被回收，如果context是某个页面的Activity，就会导致很严重的内存泄露问题。




<a name="anchor_dialog"></a>

### .Dialog不合理使用导致的内存泄露

Dialog最简单的内存泄露，当前Activity被直接Finish，但是Dialog却没有dismiss，

<a name = "reference"></a>

### 参考文档

How to Leak a Context: Handlers & Inner Classes <http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html>

