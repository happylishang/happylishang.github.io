>   dp(n)= f(dp(n-1)) 


### 动态规划的判断

* 最优解：核心问题是穷举
* 存在「重叠子问题」【斐波那契】
* 具备「最优子结构」，这里不是贪心的模型，是最优字结构集合【最小硬币数】 全局最优解， 贪心算法没有考虑全局最有解，而是局部最优解
* 带备忘录的递归

局部最优解，从上一步，上两步可以退到，全局最优，可能跟前面不定步数有关，比如，index下标


###  最优解问题

遇到求最值问题，可以考虑贪心->穷举->动态规划

* 最大子数组
* 求最长递增子数组
* 求最长递增子序列或求最长公共子串、子序列
* 最优区间
* 字符串匹配


### 求可行性



### 动态规划的步骤

* 先理解问题本身，如何将问题转换成算法语言
* 其次，状态如何定义
* 最后，状态如何转移
* 空间换时间是动态规划的根本

### 从小集合不断往后推演

空间换时间，小集合可能多余，比如最少硬币


###  动态规划自底向上，递归自顶向下

递归跟动态规划重合的点是减少重叠计算，递归就用备忘录，动态规划就用dp table 


### 编辑距离

###  字序列类的

可以用不常，或者倒着来判断，总值遍历所有的区间段


 

### 参考文档

[什么样的问题应该使用动态规划](https://segmentfault.com/a/1190000041300090)
[动态规划套路详解 ](https://www.cnblogs.com/labuladong/p/13926135.html)


### 题目考察汇总
	
>     -5. 最长回文子串 38.0% 中等	 子串 区间
   
 dp[i],前i个最长回文的长度
 
 状态转移方程 dp[i]= 当前i到dp[i-1] 或者 当前i到dp[i-1]-1是不是回文，是就更新距离，否则等于dp[i-1]
 
 dp[i][j] 是否是回文子串，dp[i-1][j-1]求解
 
>  -516. 最长回文子序列 67.1%  中等		   

序列就是区间，可以不相邻，因此用dp[i][j] ：i 到j 的最长回文序列长度

顺序，或者区间长度

状态转移方程：dp[i][i]=1;   

	i=[n-1 -> 0] 
	j=[i+1 -> n-1 ]
	<!--注意顺序，都是有效下标-->
	dp[i][j] = char[i] == char[j] ？dp[i+1][j-1]+2:Math.max(dp[i+1][j],dp[i][j-1])

第二种，步长 

	初始化步长1 =1 
	
	for(int step=2; step <=n; step++)
		for(int j=0 ;j<=n-step;j++)
			dp[j][j+step-1] = char[j] == char[j+st]  ？
			        dp[j+1][j+step-2]+2 :Math.max(dp[j][j+step-2],dp[j+1][j+step-1])

> 	-10. 正则表达式匹配  30.7% 困难	

	
	22. 括号生成
	77.6%
	中等	
	32. 最长有效括号
	37.6%
	困难	
	
> 	-42. 接雨水 63.2% 困难	
	
> 	-44. 通配符匹配 33.9% 困难	


> 	-45. 跳跃游戏 II 44.7% 中等	
> 	-53. 最大子数组和 55.2% 中等	

> 	-55. 跳跃游戏 43.3% 中等	     
	   最长臂长
	
> 	-62. 不同路径 68.0% 中等	
> 	-63. 不同路径 II 41.2% 中等	

     路径规划，可以递归，二维，最优字结构	
   
> 	-64. 最小路径和 69.9% 中等	

* 	矩阵，二维动态规划，最小路径和，
*    最优子结构集合，或者说每个子结构都有自己的最优
*    递归存在重叠，不能简单的递归

	dp[i][j] 到到ij的最优解，
	
> 	-70. 爬楼梯 54.3% 简单	
> 	-72. 编辑距离 62.8% 中等	
>    -85. 最大矩形  55.0%  
	
> 	-91. 解码方法   33.5%  中等	
	
> 	-95. 不同的二叉搜索树 II  73.8%  中等	
	 
	 递归
	
> 	-96. 不同的二叉搜索树  71.0% 中等	 回溯 递归 dp dp中有递归回溯的思想

	* 为问题建立解空间结构
	* 在解空间结构上进行DFS搜索
	* 设立回溯出口和剪枝点，减少无效搜索，出口处保存有效解.

	备忘录+递归 ==动态规划
	
	dp[i] 拆分乘积

> 	-97. 交错字符串 44.8% 中等	    

    public boolean isInterleave(String s1, String s2, String s3) {
		  // 二维的动态规划 比较容易 可以降低维度
	        if (s2.length() == 0) return s1.equals(s3);
	        if (s1.length() == 0) return s2.equals(s3);
	        if (s1.length() + s2.length() != s3.length())  return false;
	        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
	        dp[0][0] = true;
	        for (int i = 1; i <= s1.length(); i++) {
	            dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);
	        }
	        for (int i = 1; i <= s2.length(); i++) {
	            dp[0][i] = dp[0][i - 1] && s3.charAt(i - 1) == s2.charAt(i - 1);
	        }
	        for (int i = 1; i <= s1.length(); i++) {
	            for (int j = 1; j <= s2.length(); j++) {
	                dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||
	                        dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);
	            }
	
	        }
	
	        return dp[s1.length()][s2.length()];
	    }

	
> 	-115. 不同的子序列 51.7% 困难	

	dp[i][j] 前i匹配j的数量,有奇效 下标为意义，不关注时机字符


> 	-118. 杨辉三角 75.6% 简单	
> 	-119. 杨辉三角 II 68.9%  简单	
	
> 	-120. 三角形最小路径和 68.7% 中等	
	
> 	-121. 买卖股票的最佳时机 57.7% 简单	
  
      一次操作：最大差值，倒着遍历就可以
	
> 	-122. 买卖股票的最佳时机 II 73.0% 中等	
	
	高抛低吸，不知道考试的啥
	
		     if (prices.length == 1) return 0;
	        int min = prices[0];
	        int max = prices[0];
	        int total = 0;
	        for (int i = 1; i < prices.length; i++) {
	            if (prices[i] > max) {
	                max = prices[i];
	            } else {
	                total += max - min;
	                min = prices[i];
	                max = min;
	            }
	        }
	        return total + (max - min);
	        
> 	152. 乘积最大子数组 43.2% 中等	 区间问题？
	<!--区间问题，考虑二维会比较省事-->
		
		<!--很难称得上动态规划-->
		    public int maxProduct(int[] nums) {
	
	        int[] dp = new int[nums.length];
	        dp[0] = nums[0];
	        int nV = 0;
	        int max = dp[0];
	        int total = 0;
	        for (int i = 0; i < nums.length; i++) {
	            if (nums[i] == 0) {
	                total = 0;
	                nV = 0;
	                dp[i] = 0;
	            } else {
	                total = total == 0 ? nums[i] : nums[i] * total;
	                if (total >= 0) {
	                    dp[i] = total;
	                } else {
	                    nV = nV == 0 ? total : nV;
	                    dp[i] = total == nV ? nums[i] : total / nV;
	                }
	            }
	            max = Math.max(max, dp[i]);
	        }
	        return max;
	    }
	 
> 	198. 打家劫舍 54.9%  中等	
	选择 与 桩体 dp[i] 前i的最大值 也可以回溯  选择抢劫i 或者不抢劫
	
	还是状态与选择，选择影响在之前的最优字结构结果中挑选值
	
> 	300. 最长递增子序列  55.4%  中等	 递增，要对比全部，很难不增加耗时

	dp[i] i结尾的最长递增   ，找到前面的比i小的 最长的遍历全部
	
> 	-322. 零钱兑换  47.3% 中等	

	完全背包，无需考虑重复，实现即可，不考虑内外循环顺序
	
> 	-338. 比特位计数 78.7% 简单	
	
	数学技术+DP，左移操作
	
> 	-416. 分割等和子集  52.3% 中等  
        [ i j ] 前i个是否存在等于j 的组合  
	
> 	-494. 目标和 48.4% 中等	   

		输入：nums = [1,1,1,1,1], target = 3 输出：5 
		解释：一共有 5 种方法让最终目标和为 3 。
		 -1 + 1 + 1 + 1 + 1 = 3 
		 +1 - 1 + 1 + 1 + 1 = 3 
		 +1 + 1 - 1 + 1 + 1 = 3 
		 +1 + 1 + 1 - 1 + 1 = 3 
		 +1 + 1 + 1 + 1 - 1 = 3
		 
 		 回溯可以
 		 
 dp[i][j] 但是要明确 i  j的意义跟范围 还有特殊的0 。
 回溯是一种思想，带着剪枝的操作，回溯也会使用递归算反，递归是算反，是自顶向下的实现，而动态规划，其实也是这种思想，只是他是自底向上，用的是另一种递归，也是回溯，回溯的剪枝应对DP表。
 
>       -509. 斐波那契数 65.9% 简单	

> 	-518. 零钱兑换 II 70.9% 中等	

	不准重复的组合数目 将类型放在外层  回溯+动态规划
	
	

> 	-647. 回文子串 67.2% 中等	 请你统计并返回这个字符串数目

	dp[i][j ] LCR 020.


> 	-746. 使用最小花费爬楼梯 66.1% 简单	
	
	类似斐波那契，或者最小硬币数
	
> 	-1137. 第 N 个泰波那契数 	61.0% 简单	
	 同斐波那契
	
> 	-1143. 最长公共子序列 65.0% 中等	

	dp[i][j] 标识前 i j 公共子序列数目，
	
		dp[i][j] =	char[i]==char[j] ?dp[i-1][j-1] +1 :{ Math.max(dp[i][j-1],dp[i-1][j]) }  
		
	
> 	-LCR 020. 回文子串 71.2% 中等   字符串中有多少个回文子字符  **字符区间** 非最值，而是遍历所有，回溯？
	
	dp[i][j] i j 是否是回文 I<=j,然后计算所有true的数量
	countSubstrings(String s) 
		
		for[i  [n--0]] 
			for[j  [i+1,n ]]
			 dp[i][j] = char[i] == char[j] &&  dp[i+1][j-1] 
	
	汇总数量即可
	
> 	LCR 103. 零钱兑换 51.7% 中等	 最少的硬币个数 完全背包问题。非0-1背包问题
	
	状态 数目 + 选择 硬币类型
	
	 Arrays.fill(dp, max);
	coinChange(int[] coins, int amount)
		dp[amount+1] dp[0]=0;
		for(coin in coins){
	  	   dp[i]=Math.min(dp[i-coin] +1 ,dp[i])	
		}
	 return dp[amount]

	
> 	LCR 126. 斐波那契数 35.8% 简单	

	严格来说不算dp，简单的递归+重叠运算，不是求最值问题
	
> 	LCR 127. 跳跃训练 45.5%  简单	
	
	base_case
	斐波那契的变种，数学归纳 dp[i]=dp[i-1]+dp[i-1]



