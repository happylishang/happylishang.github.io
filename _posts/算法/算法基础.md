## 二叉树

* 节点的高度，自底向上看

节点的高(heigh)是一片树叶的最长路径，树叶的高都是0，一棵树的高为它的根的高

* 节点的深度，自顶向下看

任意节点深度(depth)为从根到n的唯一的路径的长，根的深度为0，一棵树的深度等于它的最深的树叶的深度;该深度总是等于这棵树的高

* 先序遍历(preordertraversal)：想要列出目录中所有文件的名字

时间复杂度，O（n）


listAll(intdepth)
		printName();
		if（isDirectory))
		foreachfilecinthisdirectory
			c.listAll(depth+1);

*后续遍历：计算被该树所有文件占用的磁盘区块的总数。

		publicintsize(file){
			intsize=0
			if(fileisdir)
				for(itmeindir)
					size+=size(item)
			elsesize=file.size;	
			returnsize
		}
		
* 二叉查找树

左子树的数，全部小于父节点的值，右子树的值全部大于父节点的值，并且，子树也同样满足这样的要求

当选及树时，我们也不明显地画出nul1链，因为具有N个节点的每一棵二叉树都将需要N+1个null链，为什么？

**N个节点的树，全部链接需要2N个链接，但是N个节点都连起来了，需要N-1个链接，所以还有N+1个是NULL。**，N个点的二叉树，必有N+1个NULL


* 中序遍历

表达式树：根据树构建表达式容易，根据表达式能构建树吗？（二元操作符）

(a+(b*c))+(((d*e)+f)*g)


后续遍历的表达式树可以重新构建二叉树，仅仅是二叉，毕竟表达式必须二叉。


* 重构二叉树

必须要有个中序遍历才能构建，先序跟后续不能构建二叉树，因为先序后续加起来也无法区分单个孩子的情况，单个孩子，左右都不影响中序跟后续的输出。

###二叉查找树:目的是用来查找--核心思想递归o(logn)

删除操作比较麻烦：一般是用**右子树的最小的数据**(很容易找到)代替该节点，并递归地删除那个节点(现在它是空的)。因为右子树中的最小的节点不可能有左儿子，所以第二次remove要容易。

	insert(r,n)
		if(n.v==r.v)returnr;
		if(n.v<r.v)	r.left=insert(r.l,n)returnr;
		else		r.right=insert(r.l,n)returnr;

	remove(r,n)
		if(n.v>r.v)if(r.left==null)returnr;r.left=remove(r.left,n)returnr;
		if(n.v<r.v)if(r.right==null)returnr;r.right=remove(r.right,n)returnr;
		//相等
		if(r.left==null)returnr.right;
		if(r.right==null)returnr.left;
		//找右侧最小，删除掉
		p=findMin(r.right);	remove(r.right,p)	p.right=r.right;p.left=r.left;returnp;
		
		
	findMin(r)
		n=r;
	while(n.left!=null){
		n=n.left
	}	
	returnn
		
		
但是删除算法有助于使得左子树比右子树深度深，在删除操作中，我们可以通过随机选取右子树的最小元素或左子树的最大元素来代替被删除的元素以消除这种不平衡问题。


###平衡查找树：AVL(Adelson-velskii和Landis)树是带有平衡条件(balancecondition)的二叉查找树

一棵AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树。一个AVL树的高度最多为1.410g(N+2)-1.328，但是实际上的高度只略大于1ogN		
AVL数的旋转：单旋转、双旋转，旋转主要记住一个东西：逆反，拨乱反正，哪里不正反哪里

*左左插入，右旋
*右右插入，左旋
*左右插入，先左旋，再右旋
*右左插入，先右旋，再左旋

**最后一步对于首个出现问题的点一定是反的，才能调整高度**，或者说，左右，右左需要先转换成左左，右右，转换后才可以。

*平衡二叉树插入：最多也只需要调整2次
*平衡二叉树的问题在于删除处理，删除节点可能失衡，导致需要从删除节点的父节点开始，不断回溯到根节点，如果平衡二叉树很高的话则需要判断多个节点。

平衡二叉树为了避免高度的重复计算，需要为每个Node添加高度，NULL的高度是-1 

		height(n)  
			
			return n==null ? -1 : n.height 

		insert(r,n)
		
			if(r==null)  n.height=0; return n;
			if(n<r.v)     r.left = insert(r.left,n) 
                  if(n>r.v) 	    r.right=  insert(r.right,n)
               	<!--直接调整，看看是不是需要-->
		      return balance(r ); //调整后，节点可能变
		
		调整最多两次
		
		 balance(r){
		 	ret 
		 	heightL =high(r.left)
		 	heightR =high(r.right)
		 	if( heightL-heightR ==0 || heightL-heightR==1 || heightL-heightR==-1 ) return r ;
		      if( heightL-heightR ==2)   
		      		if(high(r.left.left)>high(r.left.right))  
		      			 ret = singleRotateWithLeftChild( r ) 
		      		else 
		      			 ret = doubleRotateWithLeftChild( r ) 
		 	if( heightL-heightR ==-2)   
		 		 if(high(r.right.left)>high(r.right.right))  
		      			 ret = doubleRotateWithRightChild
		 		else
		 			  ret = singleRotateWithRightChild( r ) 
		 			 
	            ret.height = Math.max(height(ret.right) ,height(ret.left)) +1 
				
				return ret;
		 }
		
		 singleRotateWithLeftChild( r ) 
		 	
		 	p= r.left; 
		 	r.left = p.right;
		 	p.right = r;   r.height = Math.max(r.left ,r.right) +1 
		 	p.height = Math.max(r, p.left) +1 
		 	return p
		 
		高度获取:

		high(r){
			
			if(r==null)return0
			returnMath.max(high(r.left),high(r.right))+1
		}

二叉树的插入删除，注意返回值需要续接上parent。

		 remove(r,n)
		 
		 	if(n.v<r.v)  r.left = remove(r.left,n) ret =r;
		 	else if(n.v<r.v) r.right = remove(r.right,n)  ret =r;
		 	else if(n.left==null) return n.right
		 	else if(n.right ==null) return n.left;
		 	<!--完成值的替换，不用替换节点 也行-->
		 	<!--else { p = findMin(n.right)  p.left = n.left p.right=remove(n.right,p) ,ret = p}-->
		 	else { p = findMin(n.right)  ret = n n.v =p.v  ret.right =remove(n.right,p.v)}
		 	balance (ret )
			return ret;
