---
layout: default
title: "Binder入门与深入"
description: "Java"
categories: [android,Binder]
tags: [Binder]

---

##总结

Native层Binder进程唤醒的关键是ServiceManager这个单利中转站，Client首先找到ServiceManager，请求ServiceManager帮自己找到目标Binder Stub进程。寻找原理是Linux内核空间所有进程复用。ServiceManager找到目标Binder的node节点，并将node节点的引用节点插入到Client线程的ref树中。之后，Client就很方便的与Binder通信了，ServiceManager维护Native服务List 。Java层面的binderService，是通过AMS进行中转，如果Service没启动，就启动Service，之后进行Publish将新进程的Bidner的代理转发给各个端口，谁需要发给谁，但是5.0已经将权限回收，binderService用途不大。其实Service不是承载体，而是承载体的生命管理接口。


#### 目录
    
> [Binder概述](#sumery_binder)  
> [问题引入原理](#binder_qusetions_index)  
> [ServiceManager化身大管家](#ServiceManager)  
> [Service实现逻辑](#service_part_arch)  
> [    -- Service自身服务的实现](#service_self_implement)  
> [    -- Service注册逻辑](#service_self_register)      
> [Android应用层对Binder的支持](#java_binder_ref)      
> [    -- 应用场景](#service_self_implement)      
> [    -- 实现原理](#service_self_register)   
> [Binder面试应用](#binder_interview)     
   


<a name="binder_interview"/>

#### Binder面试问题--来说说Binder 由点及面，由面及里：点击事件如何传递到View，RootView+WindowsManager

如何理解这个Binder：从用法理解原理，而不是从原理理解用法。这大概也是比较合理的学习方式。先会说话，再学语法。Binder用来干嘛的，通信，既然是通信，就是把数据传输给目标。具体到Android就是将当前进程的数据发送给目标进程。Android的实现基本算是C/S架构，所有的核心服务有自己的独立进程。Android基于Linux内核，其进程模型就是Linux进程模型，Linux的进程通信方式完全适用于Android，或者说，就是一模一样的。

 
<a name="sumery_binder"></a>


#### Binder概述

   一句话概括进程通信：进程间的数据传递。

   Binder是Anroid系统里最重要的进程通信方式，很多文章会直接用代码、原理类的文字进行描述，对于接触Android与Linux不是特别深的人来说，特别晦涩难懂，经常是看了这忘了那里，其实探索Binder通信的一条核心就是：Client如何找Server，将请求发送给Server，Server再将结果返回给Client。

   Binder基于OpenBinder，被引入后添加了很多Android特性，比如，在驱动层添加了ServiceManager逻辑，搭建起ServiceManger-Clien-Server框架模型。Android基于Linux内核，其进程管理模型完全沿用了Linux的进程/线程模型，进程划分为用户空间与内核空间，在用户空间，进程间是无法通信的，只有通过内核空间才能传递数据。 Binder自身的意义倾向于通信，只是进程间通信的一种方式，但是在Android系统中，Binder被提到了核心高度，Android基本可以看做基于Binder模型实现的是一种Android RPC模型（远程过程调用协议 Remote Procedure Call Protocal ），即：C/S架构。
   
   Binder只是定义了Android通信模型，至于内部的业务实现，还是要有Server自身来实现，不要把数据传输跟业务处理弄混淆，Android只是基于Binder，搭建了一个C/S通信框架、或者说通信协议。Android基于Linux内核，在Linux中，Binder被看做一个字符设备，Binder驱动会为每个打开Binder的进程在内核里分配一块地址空间，Client向Server传递数据，其实就是将数据写道内核空间中Server的地址里面，然后通知Server去取数据。原理其实很简单，但是Google为了更加合理的使用Binder，自己进行了很多层次的封装与优化，导致代码看的昏头转向， 比较难的就是进程或者线程的挂起与唤醒以及Android CS框架。

<a name="binder_qusetions_index"></a>

#### Binder常见问题--由表及里引入原理探究
	
*  ServiceManager如何管理Servers

   每个Server进程在注册的时候，首先往本地进程的内核空间的Binders红黑树种插入Binder实体服务的bind_node节点，然后会在ServiceManager的进程的内核空间中为其添加引用ref结构体，ref，会保存相应的信息、名字、ptr地址等。

*   Client如何找到Server，并且向其发送请求
    Client在getService的时候，ServiceManager会找到Server的node节点，并在在Client中创建Server的bind_ref引用，Client可以在自己进程的内核空间中找到该引用，最终获取Server的bind_node节点，直接访问Server，传输数据并唤醒。

*  Client端，服务实体的引用bind_ref存在哪里了，与Handler的关系式怎么样的

	Binder驱动会在内核空间为打开Binder设备的进程（包括Client及Server端）创建bind_proc结构体，bind_proc包含4棵红黑树：threads、bind_refs、bind_nodes、bind_desc这四棵树分别记录该进程的线程树、Binder引用树、本地Binder实体，等信息，方便本地查找。Handler其是ServiceManager为了方便客户端查找bind_ref做的一套处理，只是为了标定目标。
	
* 如何唤醒目标进程或者线程：
	
	每个Binder进程或者线程在内核中都设置了自己的等待队列，Client将目标进程或者线程告诉Binder驱动，驱动负责唤醒挂起在等待队列上的线程或者进程。

* 	Server如何找到返回目标进程或者线程，Client在请求的时候，会在bind_trasaction的from中添加请求端信息

* 	如何Binder节点与ref节点的添加时机 
	
	驱动中存在一个TYPE_BINDER与TYPR_HANDLE的转换，Binder节点是Binder Server进程（一般是Native进程）在向Servicemanager注册时候添加的，而ref是Client在getService的时候添加的，并且是由ServiceManager添加的。

* 	Binder如何实现只拷贝一次

	数据从用户空间拷贝到内核中的时候，是直接拷贝到目标进程的内核空间，这个过程是在请求端线程中处理的，只不过操作对象是目标进城的内核空间。其实，内核中的bind_trasaction_data是直接在目标进程汇总分配的，由于Binder进程的Binder内存部分在内核空间跟用户空间只存在一个偏差值，用户空间不需要再次拷贝数据就可
以完成访问。

* 	Binder接收线程管理：请求发送时没有特别标记，驱动怎么判断哪些数据包该送入全局to-do队列，哪些数据包该送入特定线程的to-do队列呢？这里有两条规则：【1】

	规则1：Client发给Server的请求数据包都提交到Server进程的全局to-do队列。不过有个特例，当进程P1的中的线程T1向进程P2发送请求时，驱动会先查看一下线程T1是否也正在处理来自P2某个线程请求，（尚在处理，未完成，没有发送回复），这种情况通常发生在两个进程都有Binder实体并互相对发时请求的时候。如果在进程P2中发现了这样的线程，比如说T2，就会要求T2来处理T1的这次请求。因为T2既然向T1发送了请求尚未得到返回包，说明T2肯定（或将会）阻塞在读取返回包的状态。这时候可以让T2顺便做点事情，总比等在那里闲着好。而且如果T2不是线程池中的线程还可以为线程池分担部分工。经过优化，来自T1的请求不是提交给P2的全局to-do队列，而是送入了T2的私有to-do队列。

	规则2：对同步请求的返回数据包（由BC_REPLY发送的包）都发送到发起请求的线程的私有to-do队列中。如上面的例子，如果进程P1的线程T1发给进程P2的线程T2的是同步请求，那么T2返回的数据包将送进T1的私有to-do队列而不会提交到P1的全局to-do队列。

* Binder Server都会在ServiceManager中注册吗？

	Java层的Binder实体就不会去ServiceManager，尤其是bindService这样一种，其实是ActivityManagerService充当了ServiceManager的角色。

* IPCThreadState::joinThreadPool的真正意义是什么？
	
	可以理解加入该进程内核的线程池，进行循环，多个线程开启，其实一个就可以，怕处理不过来，可以开启多个线程处理起来，其实跟线程池类似。
	
* 为何ServiceManager启动的时候没有采用joinThreadPool，而是自己通过for循环来实现自己Loop

  因为Binder环境还没准备好啊，所以，自己控制，所以也咩有talkWithDriver那套逻辑，不用onTransact实现。因为前文也说过，Binder为Android做了深层的改变，其实在驱动里面ServiceManager也是特殊对待的，在binder_transaction中，会对目标是ServiceManager的请求进行特殊处理。	

<a name="become_service_manager"></a>

#### ServiceManager启动为管家

##### ServiceManager是由谁启动的？

 在应用层ServiceManager的使用一般如下:(基于源码4.3)

    public abstract Object getSystemService(@ServiceName @NonNull String name);
    
 那么ServiceManager是什么时候启动的呢？ServiceManager代码位于/frameworks/native/cmds/servicemanager/中，在init.rc中可以看到
    
	    service servicemanager /system/bin/servicemanager
	    class core
	    user system
	    group system
	    critical
	    onrestart restart zygote
	    onrestart restart media
	    onrestart restart surfaceflinger
	    onrestart restart drm

所以，ServiceManager是有init进程启动的，在Linux系统中init是一切用户空间进程的父进程，ServiceManager因此不依赖与任何Android服务进程。完全由系统的init进程加载进来。

##### ServiceManager如何成为系统Server的大管家

init进程启动的servicemanager的入口是service_manager.c的main函数：

		int main(int argc, char **argv)
		{
		    struct binder_state *bs;
		    void *svcmgr = BINDER_SERVICE_MANAGER;
		    bs = binder_open(128*1024);
		    if (binder_become_context_manager(bs)) {
		        LOGE("cannot become context manager (%s)\n", strerror(errno));
		        return -1;
		    }
		    svcmgr_handle = svcmgr;
		    binder_loop(bs, svcmgr_handler);
		    return 0;
		}

主要做了以下几件事情		

* 	第一步：调用函数binder_open打开设备文件/dev/binder 
* 	第二步：调用binder_become_context_manager将自己注册为Binder进程间通信机制的上下文管理者；
* 	第三步：调用函数binder_loop开启循环，监听Client进程的通信要求。
下面详细的分析一下核心函数代码：

	int binder_become_context_manager(struct binder_state *bs)
	{
	    return ioctl(bs->fd, BINDER_SET_CONTEXT_MGR, 0);
	}

进入binder驱动

	static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
	{
	     int ret;
	    struct binder_proc *proc = filp->private_data;
	    struct binder_thread *thread;
	    unsigned int size = _IOC_SIZE(cmd);
	    void __user *ubuf = (void __user *)arg;
	    
	    . . . . . .
	    . . . . . .
	    case BINDER_SET_CONTEXT_MGR:
	        . . . . . .
	        . . . . . .
	            binder_context_mgr_uid = current->cred->euid;
	        
	        binder_context_mgr_node = binder_new_node(proc, NULL, NULL);
	 if (binder_context_mgr_node == NULL) 
	        {
	            ret = -ENOMEM;
	            goto err;
	        }
	        binder_context_mgr_node->local_weak_refs++;
	        binder_context_mgr_node->local_strong_refs++;
	        binder_context_mgr_node->has_strong_ref = 1;
	        binder_context_mgr_node->has_weak_ref = 1;
	 break;
	    . . . . . .
	    . . . . . .
	}
Binder驱动为ServiceManager生成一个binder_node节点，并记入静态变量binder_context_mgr_node。一般情况下，应用层的每个binder实体都会在binder驱动层对应一个binder_node节点，然而binder_context_mgr_node比较特殊，它没有对应的应用层binder实体。系统规定：任何应用都必须使用句柄0来跨进程地访问它，因为ServiceManager独一无二，并且只有一个服务实体，所以并不需要区分Binder实体。Android规定几乎任何用户进程都可以通过0号句柄访问ServiceManager，其余Server的远程接口句柄之都是一个Binder驱动分配的大于0的值，可以在Binder驱动中看到对于请求是ServiceManager的特殊处理

关于binder_loop开启循环

	void binder_loop(struct binder_state *bs, binder_handler func)
	{
	    int res;
	    struct binder_write_read bwr;
	    unsigned readbuf[32];
	
	    bwr.write_size = 0;
	    bwr.write_consumed = 0;
	    bwr.write_buffer = 0;
	    
	    readbuf[0] = BC_ENTER_LOOPER;
	    binder_write(bs, readbuf, sizeof(unsigned));
	    for (;;) {
	        bwr.read_size = sizeof(readbuf);
	        bwr.read_consumed = 0;
	        bwr.read_buffer = (unsigned) readbuf;
	        res = ioctl(bs->fd, BINDER_WRITE_READ, &bwr);
	        res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);
	  		....
	    }
	}

可以看出ServiceManager直接通过for的ioctl进行binder字符设备的读取，如果没请求到来，就将自己的进程挂起，等待请求唤醒。一般Client的请求目标如果是ServiceManager会进行如下区分处理：
 
	 if (tr->target.handle) {//如果不是ServiceManager，也就是tr->target.handle！=0
					struct binder_ref *ref;
					ref = binder_get_ref(proc, tr->target.handle);
					if (ref == NULL) {
						binder_user_error("binder: %d:%d got "
							"transaction to invalid handle\n",
							proc->pid, thread->pid);
						return_error = BR_FAILED_REPLY;
						goto err_invalid_target_handle;
					}
					target_node = ref->node;
				} else {//如果不是ServiceManager，也就是tr->target.handle==0
					target_node = binder_context_mgr_node;
					if (target_node == NULL) {
						return_error = BR_DEAD_REPLY;
						goto err_no_context_mgr_node;
					}
				
到这里我们就知道，ServiceManager怎么启动、究竟做什么，以及客户端如何找到ServiceManager的逻辑。下面就来看一下Server如何将自己注册到ServiceManager中，以及Client如何通过，。ServiceManager找到目标Server。			
					
<a name="service_part_arch"></a>
					
####  系统Server实现逻辑 

##### Server（Native层）如何注册到ServiceManager？

系统启动的时候，init进程会先启动ServicManager进程，之后，init会启动mediaserver进程，注意mediaserver不是SysytemServer启动的，而是init启动的。MediaPlayerServiceService的，SystemServer.java通过init1调用Jni函数，mediaserver配置在init.rc配置文件中，init.rc中的Service服务进程是顺序启动的。

	service media /system/bin/mediaserver
	    class main
	    user media
	    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm
	    ioprio rt 4
	    
mediaserver的入口是/frameworks/av/media/mediaserver/main_mediaserver.cpp的main函数：

		int main(int argc, char** argv){
		
		    sp<ProcessState> proc(ProcessState::self());
		
		    sp<IServiceManager> sm = defaultServiceManager();
		
		    AudioFlinger::instantiate(); //内含注册到ServiceManager
		    MediaPlayerService::instantiate();//内含注册到ServiceManager
		    CameraService::instantiate();//内含注册到ServiceManager
		    AudioPolicyService::instantiate();//内含注册到ServiceManager
		
		    ProcessState::self()->startThreadPool();
		    IPCThreadState::self()->joinThreadPool();
		}

通过以上代码，可以看出一个进程可以同时注册了多个服务，那么到底是怎么注册到ServiceManager呢。主观上想就是通过defaultServiceManager()获取ServiceManager的远程代理，然后通过代理发送请求，将服务Server信息注册到ServiceManager中。

defaultServiceManager函数如何获取ServiceManager的远程代理呢？
		
##### Server如何开启自身的Binder监听Loop？

Native层，Binder实体一般都要事先BBinder接口，关键是实现函数onTransact调用逻辑  核心的一句话：实现自己的逻辑，之后，利用统一的入口进入Loop循环，接到请求，统一回调入口。入口就Ibinder。核心函数

    ProcessState::self()->startThreadPool();
    IPCThreadState::self()->joinThreadPool();
    
	    void IPCThreadState::joinThreadPool(bool isMain){
	  
	    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);    
	    status_t result;
	    do {
            ...
	
	        // now get the next command to be processed, waiting if necessary
	        result = talkWithDriver();
	        if (result >= NO_ERROR) {
	            size_t IN = mIn.dataAvail();
	            if (IN < sizeof(int32_t)) continue;
	            cmd = mIn.readInt32();
	            result = executeCommand(cmd);
	        }  
	        
	   
	    } while (result != -ECONNREFUSED && result != -EBADF);
	
	    LOG_THREADPOOL("**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%p\n",
	        (void*)pthread_self(), getpid(), (void*)result);
	    
	    mOut.writeInt32(BC_EXIT_LOOPER);
	    talkWithDriver(false);
	}


这里的框架如何抽象如此完美？业务逻辑跟底层通信完美的分离与统一？采用什么设计模式？统一了Ibind而接口，上层定义协议？因为主线程如果退出，程序就退出，所以主线程也要进入循环。如果是Java层，可以不用担心因为ActivityThread会保证UI Thread进入循环。startThreadPool回传给底层BC_ENTER_LOOPER参数，其目的是什么，只是向Binder驱动注册通报一声，我这个服务要作为Binder监听主线程服务了。其实你要注意，只要你在proc，当前进程中实现了BBinder服务，并且完成了注册，那么ProcessState::self()->startThreadPool();开启的线程就可以访问改BBinder，这个底层是统一的。只要进入循环，Binder就起来了。只要通过joinThreadPool进入循环，这条Binder服务的路线就已经起来了,为什么说事服务呢？而不是请求，请求走这条线路吗？请求是不走的，因为请求是异步或者阻塞的。不需要单独一个Loop进行维护。
